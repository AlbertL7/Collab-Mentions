/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CollabMentionsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/types.ts
var GENERAL_CHANNEL_ID = "general";
var DEFAULT_SETTINGS = {
  enableNotifications: true,
  notificationSound: true,
  autoMarkReadDelay: 0,
  showMentionHighlights: true,
  mentionColor: "#7c3aed",
  autoCleanup: true,
  maxMentionsPerUser: 30,
  cleanupIntervalHours: 24,
  enableFileWatcher: true,
  notifiedMentionIdsByUser: {},
  lastNotifiedChatTimestampByUser: {}
};

// src/userManager.ts
var import_obsidian = require("obsidian");
var os = __toESM(require("os"));
var USERS_FILE = ".collab-mentions/users.json";
var PRESENCE_FILE = ".collab-mentions/presence.json";
var LOCK_FILE = ".collab-mentions/users.lock";
var MAX_SAVE_RETRIES = 3;
var MAX_REGISTRATION_RETRIES = 3;
var LOCK_TIMEOUT = 1e4;
var ACTIVE_THRESHOLD = 5 * 60 * 1e3;
var HEARTBEAT_THRESHOLD = 30 * 1e3;
var UserManager = class {
  // 5 minutes
  constructor(app) {
    this.currentUser = null;
    this.usersConfig = { users: [] };
    this.presenceData = { presence: [] };
    // Track recently deleted users to prevent merge from re-adding them
    this.recentlyDeletedUsers = /* @__PURE__ */ new Map();
    // localIdentifier -> deletion timestamp
    this.USER_DELETE_PROTECTION = 3e5;
    this.app = app;
  }
  /**
   * Fast non-cryptographic hash (FNV-1a) for save verification
   * Much faster than SHA-256 - optimized for speed, not security
   */
  computeHash(content) {
    let hash = 2166136261;
    for (let i = 0; i < content.length; i++) {
      hash ^= content.charCodeAt(i);
      hash = hash * 16777619 >>> 0;
    }
    return hash.toString(16);
  }
  /**
   * Acquire a lock for user registration/modification.
   * Uses a lock file with timestamp to handle stale locks.
   * @returns true if lock acquired, false if failed
   */
  async acquireLock() {
    const lockPath = LOCK_FILE;
    const localId = this.getLocalIdentifier();
    const now = Date.now();
    try {
      if (await this.app.vault.adapter.exists(lockPath)) {
        const content = await this.app.vault.adapter.read(lockPath);
        try {
          const lockData2 = JSON.parse(content);
          const lockAge = now - lockData2.timestamp;
          if (lockAge > LOCK_TIMEOUT) {
            console.debug("[Collab-Mentions] Stale lock found, taking over");
          } else if (lockData2.holder !== localId) {
            console.debug("[Collab-Mentions] Lock held by:", lockData2.holder);
            return false;
          }
        } catch (e) {
          console.debug("[Collab-Mentions] Invalid lock file, taking over");
        }
      }
      const lockData = {
        holder: localId,
        timestamp: now
      };
      await this.app.vault.adapter.write(lockPath, JSON.stringify(lockData));
      await new Promise((resolve) => setTimeout(resolve, 50));
      const verifyContent = await this.app.vault.adapter.read(lockPath);
      const verifyData = JSON.parse(verifyContent);
      if (verifyData.holder === localId) {
        console.debug("[Collab-Mentions] Lock acquired");
        return true;
      } else {
        console.debug("[Collab-Mentions] Lost lock race to:", verifyData.holder);
        return false;
      }
    } catch (error) {
      console.error("[Collab-Mentions] Error acquiring lock:", error);
      return false;
    }
  }
  /**
   * Release the registration lock
   */
  async releaseLock() {
    const lockPath = LOCK_FILE;
    const localId = this.getLocalIdentifier();
    try {
      if (await this.app.vault.adapter.exists(lockPath)) {
        const content = await this.app.vault.adapter.read(lockPath);
        try {
          const lockData = JSON.parse(content);
          if (lockData.holder === localId) {
            await this.app.vault.adapter.remove(lockPath);
            console.debug("[Collab-Mentions] Lock released");
          }
        } catch (e) {
          await this.app.vault.adapter.remove(lockPath);
        }
      }
    } catch (error) {
      console.error("[Collab-Mentions] Error releasing lock:", error);
    }
  }
  /**
   * Check if a user was recently deleted (within protection window)
   */
  isRecentlyDeletedUser(localIdentifier) {
    const deletedTime = this.recentlyDeletedUsers.get(localIdentifier);
    if (!deletedTime)
      return false;
    const age = Date.now() - deletedTime;
    if (age > this.USER_DELETE_PROTECTION) {
      this.recentlyDeletedUsers.delete(localIdentifier);
      return false;
    }
    return true;
  }
  /**
   * Load presence data from vault
   */
  async loadPresence() {
    try {
      if (await this.app.vault.adapter.exists(PRESENCE_FILE)) {
        const content = await this.app.vault.adapter.read(PRESENCE_FILE);
        this.presenceData = JSON.parse(content);
      } else {
        this.presenceData = { presence: [] };
      }
    } catch (error) {
      console.error("Failed to load presence data:", error);
      this.presenceData = { presence: [] };
    }
  }
  /**
   * Save presence data to vault with verification
   */
  async savePresence() {
    try {
      const content = JSON.stringify(this.presenceData, null, 2);
      const expectedHash = this.computeHash(content);
      for (let attempt = 1; attempt <= MAX_SAVE_RETRIES; attempt++) {
        await this.app.vault.adapter.write(PRESENCE_FILE, content);
        try {
          const savedContent = await this.app.vault.adapter.read(PRESENCE_FILE);
          const savedHash = this.computeHash(savedContent);
          if (savedHash === expectedHash) {
            return;
          } else {
            console.warn(`[Collab-Mentions] Presence save verification failed (attempt ${attempt}/${MAX_SAVE_RETRIES})`);
          }
        } catch (verifyError) {
          console.warn(`[Collab-Mentions] Presence save verification failed (attempt ${attempt}/${MAX_SAVE_RETRIES}):`, verifyError);
        }
        if (attempt < MAX_SAVE_RETRIES) {
          await new Promise((resolve) => setTimeout(resolve, 50 * attempt));
        }
      }
    } catch (error) {
      console.error("Failed to save presence data:", error);
    }
  }
  /**
   * Update heartbeat for current user
   * @param activeFile - The currently open file (if any)
   * @param isFileActivity - Whether this is triggered by actual file interaction
   */
  async updateHeartbeat(activeFile, isFileActivity = false) {
    if (!this.currentUser)
      return;
    await this.loadPresence();
    const now = new Date().toISOString();
    const existingIndex = this.presenceData.presence.findIndex(
      (p) => p.vaultName === this.currentUser.vaultName
    );
    const existingPresence = existingIndex !== -1 ? this.presenceData.presence[existingIndex] : null;
    const presenceEntry = {
      vaultName: this.currentUser.vaultName,
      lastSeen: now,
      // Always update heartbeat
      lastActivity: isFileActivity ? now : (existingPresence == null ? void 0 : existingPresence.lastActivity) || now,
      // Only update activity on file interaction
      activeFile,
      manualStatus: existingPresence == null ? void 0 : existingPresence.manualStatus
      // Preserve manual status
    };
    if (existingIndex !== -1) {
      this.presenceData.presence[existingIndex] = presenceEntry;
    } else {
      this.presenceData.presence.push(presenceEntry);
    }
    await this.savePresence();
  }
  /**
   * Record file activity (user clicked/edited a file)
   */
  async recordFileActivity(activeFile) {
    await this.updateHeartbeat(activeFile, true);
  }
  /**
   * Get user status based on heartbeat and activity
   * - Active: File activity within last 5 minutes
   * - Snooze: Vault is open (heartbeat recent) but no activity for 5+ minutes
   * - Offline: Vault is closed (no recent heartbeat)
   *
   * Manual status overrides automatic detection (except 'auto')
   */
  getUserStatus(vaultName) {
    const presence = this.presenceData.presence.find(
      (p) => p.vaultName.toLowerCase() === vaultName.toLowerCase()
    );
    if (!presence) {
      return "offline";
    }
    if (presence.manualStatus && presence.manualStatus !== "auto") {
      return presence.manualStatus;
    }
    const now = Date.now();
    const lastSeen = new Date(presence.lastSeen).getTime();
    const heartbeatAge = now - lastSeen;
    if (heartbeatAge > HEARTBEAT_THRESHOLD) {
      return "offline";
    }
    const lastActivity = presence.lastActivity ? new Date(presence.lastActivity).getTime() : lastSeen;
    const activityAge = now - lastActivity;
    if (activityAge <= ACTIVE_THRESHOLD) {
      return "active";
    }
    return "snooze";
  }
  /**
   * Get presence info for a user
   */
  getUserPresence(vaultName) {
    return this.presenceData.presence.find(
      (p) => p.vaultName.toLowerCase() === vaultName.toLowerCase()
    );
  }
  /**
   * Get the current user's manual status setting
   */
  getCurrentUserManualStatus() {
    if (!this.currentUser)
      return "auto";
    const presence = this.getUserPresence(this.currentUser.vaultName);
    return (presence == null ? void 0 : presence.manualStatus) || "auto";
  }
  /**
   * Set manual status for the current user
   * @param status - 'auto' for automatic detection, or 'active'/'snooze'/'offline' for manual override
   */
  async setManualStatus(status) {
    if (!this.currentUser)
      return;
    await this.loadPresence();
    const existingIndex = this.presenceData.presence.findIndex(
      (p) => p.vaultName === this.currentUser.vaultName
    );
    if (existingIndex !== -1) {
      this.presenceData.presence[existingIndex].manualStatus = status;
    } else {
      const now = new Date().toISOString();
      this.presenceData.presence.push({
        vaultName: this.currentUser.vaultName,
        lastSeen: now,
        lastActivity: now,
        manualStatus: status
      });
    }
    await this.savePresence();
    const statusText = status === "auto" ? "Automatic" : status.charAt(0).toUpperCase() + status.slice(1);
    new import_obsidian.Notice(`Status set to: ${statusText}`);
  }
  /**
   * Set typing status for current user in a channel
   */
  async setTyping(channelId) {
    if (!this.currentUser)
      return;
    await this.loadPresence();
    const existingIndex = this.presenceData.presence.findIndex(
      (p) => p.vaultName === this.currentUser.vaultName
    );
    if (existingIndex !== -1) {
      this.presenceData.presence[existingIndex].typingInChannel = channelId;
      this.presenceData.presence[existingIndex].typingStarted = new Date().toISOString();
    }
    await this.savePresence();
  }
  /**
   * Clear typing status for current user
   */
  async clearTyping() {
    if (!this.currentUser)
      return;
    await this.loadPresence();
    const existingIndex = this.presenceData.presence.findIndex(
      (p) => p.vaultName === this.currentUser.vaultName
    );
    if (existingIndex !== -1) {
      this.presenceData.presence[existingIndex].typingInChannel = void 0;
      this.presenceData.presence[existingIndex].typingStarted = void 0;
    }
    await this.savePresence();
  }
  /**
   * Get users currently typing in a channel
   * Only returns users who started typing within the last 5 seconds
   */
  getTypingUsers(channelId) {
    const now = Date.now();
    const TYPING_TIMEOUT = 5e3;
    return this.presenceData.presence.filter((p) => {
      var _a;
      if (p.typingInChannel !== channelId)
        return false;
      if (!p.typingStarted)
        return false;
      if (p.vaultName === ((_a = this.currentUser) == null ? void 0 : _a.vaultName))
        return false;
      const typingAge = now - new Date(p.typingStarted).getTime();
      return typingAge < TYPING_TIMEOUT;
    }).map((p) => p.vaultName);
  }
  /**
   * Get all users with their current status
   */
  getAllUsersWithStatus() {
    return this.usersConfig.users.map((user) => {
      const presence = this.getUserPresence(user.vaultName);
      return {
        ...user,
        status: this.getUserStatus(user.vaultName),
        lastSeen: presence == null ? void 0 : presence.lastSeen
      };
    });
  }
  /**
   * Clear presence for current user (called on unload)
   */
  async clearPresence() {
    if (!this.currentUser)
      return;
    await this.loadPresence();
    this.presenceData.presence = this.presenceData.presence.filter(
      (p) => p.vaultName !== this.currentUser.vaultName
    );
    await this.savePresence();
  }
  /**
   * Get the local machine identifier (username@hostname)
   */
  getLocalIdentifier() {
    const username = os.userInfo().username;
    const hostname2 = os.hostname();
    return `${username}@${hostname2}`;
  }
  /**
   * Get the current operating system
   */
  getOS() {
    return process.platform;
  }
  /**
   * Get the path to the users file
   */
  getUsersFilePath() {
    return USERS_FILE;
  }
  /**
   * Load users configuration from vault
   */
  async loadUsers() {
    try {
      const configPath = USERS_FILE;
      if (!await this.app.vault.adapter.exists(".collab-mentions")) {
        await this.app.vault.adapter.mkdir(".collab-mentions");
      }
      if (await this.app.vault.adapter.exists(configPath)) {
        const content = await this.app.vault.adapter.read(configPath);
        this.usersConfig = JSON.parse(content);
        console.debug("[Collab-Mentions] Loaded users:", this.usersConfig.users.map((u) => u.vaultName));
        await this.ensureAdminExists();
      } else {
        console.debug("[Collab-Mentions] No users file found, creating empty config");
        this.usersConfig = { users: [] };
        await this.saveUsers();
      }
    } catch (error) {
      console.error("[Collab-Mentions] Failed to load users config:", error);
      this.usersConfig = { users: [] };
    }
  }
  /**
   * Migration: Ensure registration numbers and admin status are properly set
   */
  async ensureAdminExists() {
    if (this.usersConfig.users.length === 0)
      return;
    let needsSave = false;
    const usersWithoutRegNum = this.usersConfig.users.filter((u) => !u.registrationNumber);
    if (usersWithoutRegNum.length > 0) {
      const sortedUsers = [...this.usersConfig.users].sort(
        (a, b) => new Date(a.registered).getTime() - new Date(b.registered).getTime()
      );
      sortedUsers.forEach((sortedUser, index) => {
        const userInConfig = this.usersConfig.users.find((u) => u.vaultName === sortedUser.vaultName);
        if (userInConfig && !userInConfig.registrationNumber) {
          userInConfig.registrationNumber = index + 1;
          needsSave = true;
          console.debug(`[Collab-Mentions] Migration: Assigned registration #${index + 1} to ${userInConfig.vaultName}`);
        }
      });
    }
    const primaryAdmins = this.usersConfig.users.filter((u) => u.adminLevel === "primary");
    console.debug("[Collab-Mentions] Current primary admins:", primaryAdmins.map((u) => u.vaultName));
    if (primaryAdmins.length !== 1) {
      for (const user of this.usersConfig.users) {
        if (user.adminLevel === "primary" && user.registrationNumber !== 1) {
          user.adminLevel = "secondary";
          needsSave = true;
          console.debug(`[Collab-Mentions] Migration: Demoted ${user.vaultName} from primary to secondary admin`);
        }
      }
    }
    const firstUser = this.usersConfig.users.find((u) => u.registrationNumber === 1);
    if (firstUser) {
      if (!firstUser.isAdmin || firstUser.adminLevel !== "primary") {
        firstUser.isAdmin = true;
        firstUser.adminLevel = "primary";
        needsSave = true;
        console.debug(`[Collab-Mentions] Migration: Set ${firstUser.vaultName} as primary admin (registration #1)`);
      }
    }
    for (const user of this.usersConfig.users) {
      if (user.isAdmin && !user.adminLevel && user.registrationNumber !== 1) {
        user.adminLevel = "secondary";
        needsSave = true;
        console.debug(`[Collab-Mentions] Migration: Set ${user.vaultName} as secondary admin`);
      }
    }
    console.debug("[Collab-Mentions] Users after migration:", this.usersConfig.users.map((u) => ({
      name: u.vaultName,
      regNum: u.registrationNumber,
      isAdmin: u.isAdmin,
      adminLevel: u.adminLevel
    })));
    if (needsSave) {
      await this.saveUsers();
    }
  }
  /**
   * Save users configuration to vault with merge logic for concurrent registrations
   */
  async saveUsers() {
    try {
      if (await this.app.vault.adapter.exists(USERS_FILE)) {
        try {
          const diskContent = await this.app.vault.adapter.read(USERS_FILE);
          const diskConfig = JSON.parse(diskContent);
          const ourLocalIds = new Set(this.usersConfig.users.map((u) => u.localIdentifier));
          for (const diskUser of diskConfig.users) {
            if (!ourLocalIds.has(diskUser.localIdentifier)) {
              if (this.isRecentlyDeletedUser(diskUser.localIdentifier)) {
                console.debug("[Collab-Mentions] Skipping recently deleted user:", diskUser.vaultName);
                continue;
              }
              console.debug("[Collab-Mentions] Merging user from disk:", diskUser.vaultName);
              this.usersConfig.users.push(diskUser);
            }
          }
          this.usersConfig.users.sort(
            (a, b) => new Date(a.registered).getTime() - new Date(b.registered).getTime()
          );
          this.usersConfig.users.forEach((user, index) => {
            user.registrationNumber = index + 1;
          });
          let hasPrimary = false;
          for (const user of this.usersConfig.users) {
            if (user.registrationNumber === 1) {
              user.isAdmin = true;
              user.adminLevel = "primary";
              hasPrimary = true;
            } else if (user.adminLevel === "primary") {
              user.adminLevel = "secondary";
              console.debug("[Collab-Mentions] Demoted duplicate primary admin:", user.vaultName);
            }
          }
          console.debug("[Collab-Mentions] After merge - users:", this.usersConfig.users.map((u) => ({
            name: u.vaultName,
            regNum: u.registrationNumber,
            adminLevel: u.adminLevel
          })));
        } catch (e) {
          console.warn("[Collab-Mentions] Failed to merge users, saving anyway:", e);
        }
      }
      const content = JSON.stringify(this.usersConfig, null, 2);
      const expectedHash = this.computeHash(content);
      for (let attempt = 1; attempt <= MAX_SAVE_RETRIES; attempt++) {
        await this.app.vault.adapter.write(USERS_FILE, content);
        try {
          const savedContent = await this.app.vault.adapter.read(USERS_FILE);
          const savedHash = this.computeHash(savedContent);
          if (savedHash === expectedHash) {
            console.debug("[Collab-Mentions] Users saved and verified (attempt", attempt + ")");
            return;
          } else {
            console.warn(`[Collab-Mentions] Users save verification failed (attempt ${attempt}/${MAX_SAVE_RETRIES}), hash mismatch`);
          }
        } catch (verifyError) {
          console.warn(`[Collab-Mentions] Users save verification failed (attempt ${attempt}/${MAX_SAVE_RETRIES}):`, verifyError);
        }
        if (attempt < MAX_SAVE_RETRIES) {
          await new Promise((resolve) => setTimeout(resolve, 100 * attempt));
        }
      }
      console.error("[Collab-Mentions] Failed to verify users save after", MAX_SAVE_RETRIES, "attempts");
    } catch (error) {
      console.error("Failed to save users config:", error);
      new import_obsidian.Notice("Failed to save user configuration");
    }
  }
  /**
   * Identify the current user based on local machine identifier
   */
  identifyCurrentUser() {
    const localId = this.getLocalIdentifier();
    this.currentUser = this.usersConfig.users.find(
      (user) => user.localIdentifier === localId
    ) || null;
    return this.currentUser;
  }
  /**
   * Register a new user or claim an existing vault name.
   * Uses file-level locking and retry logic to prevent race conditions.
   */
  async registerUser(vaultName) {
    const localId = this.getLocalIdentifier();
    const currentOS = this.getOS();
    for (let attempt = 1; attempt <= MAX_REGISTRATION_RETRIES; attempt++) {
      console.debug(`[Collab-Mentions] Registration attempt ${attempt}/${MAX_REGISTRATION_RETRIES}`);
      const lockAcquired = await this.acquireLock();
      if (!lockAcquired) {
        if (attempt < MAX_REGISTRATION_RETRIES) {
          const waitTime = 500 * attempt;
          console.debug(`[Collab-Mentions] Could not acquire lock, waiting ${waitTime}ms...`);
          await new Promise((resolve) => setTimeout(resolve, waitTime));
          continue;
        } else {
          new import_obsidian.Notice("Registration busy, please try again in a moment");
          return false;
        }
      }
      try {
        await this.loadUsers();
        console.debug("[Collab-Mentions] Registration: Reloaded users, count:", this.usersConfig.users.length);
        const existingByLocal = this.usersConfig.users.find(
          (user) => user.localIdentifier === localId
        );
        if (existingByLocal) {
          new import_obsidian.Notice(`This machine is already registered as "${existingByLocal.vaultName}"`);
          return false;
        }
        const existingByName = this.usersConfig.users.find(
          (user) => user.vaultName.toLowerCase() === vaultName.toLowerCase()
        );
        if (existingByName) {
          new import_obsidian.Notice(`The name "${vaultName}" is already taken by another user`);
          return false;
        }
        const colors = ["#7c3aed", "#2563eb", "#059669", "#d97706", "#dc2626", "#7c2d12", "#4f46e5", "#0891b2"];
        const color = colors[this.usersConfig.users.length % colors.length];
        const maxRegNum = this.usersConfig.users.reduce((max, user) => Math.max(max, user.registrationNumber || 0), 0);
        const registrationNumber = maxRegNum + 1;
        const isFirstUser = registrationNumber === 1;
        const newUser = {
          vaultName,
          localIdentifier: localId,
          os: currentOS,
          registered: new Date().toISOString(),
          registrationNumber,
          color,
          isAdmin: isFirstUser,
          // First user is automatically admin
          adminLevel: isFirstUser ? "primary" : void 0
          // First user is primary admin
        };
        this.usersConfig.users.push(newUser);
        await this.saveUsers();
        await this.loadUsers();
        const verifiedUser = this.usersConfig.users.find(
          (user) => user.localIdentifier === localId && user.vaultName === vaultName
        );
        if (verifiedUser) {
          this.currentUser = verifiedUser;
          new import_obsidian.Notice(`Successfully registered as "${vaultName}"`);
          return true;
        } else {
          console.debug("[Collab-Mentions] Registration not verified, retrying...");
          if (attempt >= MAX_REGISTRATION_RETRIES) {
            new import_obsidian.Notice("Registration failed, please try again");
            return false;
          }
          continue;
        }
      } finally {
        await this.releaseLock();
      }
    }
    new import_obsidian.Notice("Registration failed after multiple attempts");
    return false;
  }
  /**
   * Unregister the current user
   * If the primary admin unregisters, promotes the next user by registration number
   */
  async unregisterCurrentUser() {
    if (!this.currentUser) {
      new import_obsidian.Notice("No user is currently registered on this machine");
      return false;
    }
    const index = this.usersConfig.users.findIndex(
      (user) => {
        var _a;
        return user.localIdentifier === ((_a = this.currentUser) == null ? void 0 : _a.localIdentifier);
      }
    );
    if (index !== -1) {
      const name = this.currentUser.vaultName;
      const wasPrimaryAdmin = this.currentUser.adminLevel === "primary";
      this.recentlyDeletedUsers.set(this.currentUser.localIdentifier, Date.now());
      console.debug("[Collab-Mentions] Tracking unregistered user:", name);
      this.usersConfig.users.splice(index, 1);
      if (wasPrimaryAdmin && this.usersConfig.users.length > 0) {
        const sortedUsers = [...this.usersConfig.users].sort(
          (a, b) => (a.registrationNumber || 999) - (b.registrationNumber || 999)
        );
        const newPrimaryAdmin = sortedUsers[0];
        const userInConfig = this.usersConfig.users.find(
          (u) => u.vaultName === newPrimaryAdmin.vaultName
        );
        if (userInConfig) {
          userInConfig.isAdmin = true;
          userInConfig.adminLevel = "primary";
          console.debug(`Primary admin left. Promoted ${userInConfig.vaultName} to primary admin.`);
          new import_obsidian.Notice(`${userInConfig.vaultName} has been promoted to primary admin`);
        }
      }
      await this.saveUsers();
      this.currentUser = null;
      new import_obsidian.Notice(`Unregistered "${name}" from this machine`);
      return true;
    }
    return false;
  }
  /**
   * Get the current user
   */
  getCurrentUser() {
    return this.currentUser;
  }
  /**
   * Get all registered users
   */
  getAllUsers() {
    return this.usersConfig.users;
  }
  /**
   * Get a user by vault name
   */
  getUserByName(vaultName) {
    return this.usersConfig.users.find(
      (user) => user.vaultName.toLowerCase() === vaultName.toLowerCase()
    );
  }
  /**
   * Check if the current machine is registered
   */
  isRegistered() {
    return this.currentUser !== null;
  }
  // ===== Admin Methods =====
  /**
   * Check if the current user is an admin
   */
  isCurrentUserAdmin() {
    var _a;
    return ((_a = this.currentUser) == null ? void 0 : _a.isAdmin) === true;
  }
  /**
   * Check if the current user is the primary admin
   */
  isCurrentUserPrimaryAdmin() {
    var _a, _b;
    return ((_a = this.currentUser) == null ? void 0 : _a.isAdmin) === true && ((_b = this.currentUser) == null ? void 0 : _b.adminLevel) === "primary";
  }
  /**
   * Check if a specific user is an admin
   */
  isUserAdmin(vaultName) {
    const user = this.getUserByName(vaultName);
    return (user == null ? void 0 : user.isAdmin) === true;
  }
  /**
   * Check if a specific user is the primary admin
   */
  isUserPrimaryAdmin(vaultName) {
    const user = this.getUserByName(vaultName);
    return (user == null ? void 0 : user.isAdmin) === true && (user == null ? void 0 : user.adminLevel) === "primary";
  }
  /**
   * Get all admin users
   */
  getAdmins() {
    return this.usersConfig.users.filter((user) => user.isAdmin === true);
  }
  /**
   * Get the primary admin
   */
  getPrimaryAdmin() {
    return this.usersConfig.users.find((user) => user.adminLevel === "primary");
  }
  /**
   * Promote a user to secondary admin (requires current user to be PRIMARY admin)
   */
  async promoteToAdmin(vaultName) {
    if (!this.isCurrentUserPrimaryAdmin()) {
      new import_obsidian.Notice("Only the primary admin can promote other users");
      return false;
    }
    const user = this.usersConfig.users.find(
      (u) => u.vaultName.toLowerCase() === vaultName.toLowerCase()
    );
    if (!user) {
      new import_obsidian.Notice(`User "${vaultName}" not found`);
      return false;
    }
    if (user.isAdmin) {
      new import_obsidian.Notice(`${vaultName} is already an admin`);
      return false;
    }
    user.isAdmin = true;
    user.adminLevel = "secondary";
    await this.saveUsers();
    new import_obsidian.Notice(`${vaultName} is now a secondary admin`);
    return true;
  }
  /**
   * Demote a user from admin (requires current user to be PRIMARY admin)
   * Cannot demote the primary admin
   */
  async demoteFromAdmin(vaultName) {
    if (!this.isCurrentUserPrimaryAdmin()) {
      new import_obsidian.Notice("Only the primary admin can demote other admins");
      return false;
    }
    const user = this.usersConfig.users.find(
      (u) => u.vaultName.toLowerCase() === vaultName.toLowerCase()
    );
    if (!user) {
      new import_obsidian.Notice(`User "${vaultName}" not found`);
      return false;
    }
    if (!user.isAdmin) {
      new import_obsidian.Notice(`${vaultName} is not an admin`);
      return false;
    }
    if (user.adminLevel === "primary") {
      new import_obsidian.Notice("Cannot demote the primary admin");
      return false;
    }
    user.isAdmin = false;
    user.adminLevel = void 0;
    await this.saveUsers();
    new import_obsidian.Notice(`${vaultName} is no longer an admin`);
    return true;
  }
  /**
   * Remove a user from the system (admin only)
   */
  async removeUser(vaultName) {
    var _a;
    if (!this.isCurrentUserAdmin()) {
      new import_obsidian.Notice("Only admins can remove users");
      return false;
    }
    if (((_a = this.currentUser) == null ? void 0 : _a.vaultName.toLowerCase()) === vaultName.toLowerCase()) {
      new import_obsidian.Notice("Cannot remove yourself. Use unregister instead.");
      return false;
    }
    const index = this.usersConfig.users.findIndex(
      (u) => u.vaultName.toLowerCase() === vaultName.toLowerCase()
    );
    if (index === -1) {
      new import_obsidian.Notice(`User "${vaultName}" not found`);
      return false;
    }
    const userToRemove = this.usersConfig.users[index];
    this.recentlyDeletedUsers.set(userToRemove.localIdentifier, Date.now());
    console.debug("[Collab-Mentions] Tracking deleted user:", userToRemove.vaultName, userToRemove.localIdentifier);
    this.usersConfig.users.splice(index, 1);
    await this.saveUsers();
    new import_obsidian.Notice(`Removed user "${vaultName}"`);
    return true;
  }
};

// src/mentionParser.ts
var MENTIONS_FILE = ".collab-mentions/mentions.json";
var MAX_SAVE_RETRIES2 = 3;
var MentionParser = class {
  constructor(app, userManager) {
    this.mentionsData = { mentions: [] };
    this.mentionRegex = /@(\w+)/g;
    this.app = app;
    this.userManager = userManager;
  }
  /**
   * Fast non-cryptographic hash (FNV-1a) for verification and deduplication
   * Much faster than SHA-256 - optimized for speed, not security
   */
  computeHash(content) {
    let hash = 2166136261;
    for (let i = 0; i < content.length; i++) {
      hash ^= content.charCodeAt(i);
      hash = hash * 16777619 >>> 0;
    }
    return hash.toString(16);
  }
  /**
   * Generate a simple unique ID
   */
  generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2, 11);
  }
  /**
   * Generate a content-based hash for a mention (for deduplication)
   */
  getMentionContentHash(mention) {
    const content = `${mention.to}|${mention.from}|${mention.file}|${mention.context}`;
    return this.computeHash(content);
  }
  /**
   * Load mentions from vault
   */
  async loadMentions() {
    try {
      if (!await this.app.vault.adapter.exists(".collab-mentions")) {
        await this.app.vault.adapter.mkdir(".collab-mentions");
      }
      if (await this.app.vault.adapter.exists(MENTIONS_FILE)) {
        const content = await this.app.vault.adapter.read(MENTIONS_FILE);
        this.mentionsData = JSON.parse(content);
      } else {
        this.mentionsData = { mentions: [] };
        await this.saveMentions();
      }
    } catch (error) {
      console.error("Failed to load mentions:", error);
      this.mentionsData = { mentions: [] };
    }
  }
  /**
   * Save mentions to vault with merge strategy to prevent data loss
   */
  async saveMentions() {
    try {
      if (!await this.app.vault.adapter.exists(".collab-mentions")) {
        await this.app.vault.adapter.mkdir(".collab-mentions");
      }
      if (await this.app.vault.adapter.exists(MENTIONS_FILE)) {
        try {
          const diskContent = await this.app.vault.adapter.read(MENTIONS_FILE);
          const diskData = JSON.parse(diskContent);
          const ourMentionIds = new Set(this.mentionsData.mentions.map((m) => m.id));
          for (const mention of diskData.mentions) {
            if (!ourMentionIds.has(mention.id)) {
              this.mentionsData.mentions.push(mention);
            } else {
              const ourMention = this.mentionsData.mentions.find((m) => m.id === mention.id);
              if (ourMention && mention.read && !ourMention.read) {
                ourMention.read = true;
                ourMention.readAt = mention.readAt;
              }
              if (mention.replies && mention.replies.length > 0 && ourMention) {
                if (!ourMention.replies)
                  ourMention.replies = [];
                const ourReplyIds = new Set(ourMention.replies.map((r) => r.id));
                for (const reply of mention.replies) {
                  if (!ourReplyIds.has(reply.id)) {
                    ourMention.replies.push(reply);
                  }
                }
                ourMention.replies.sort(
                  (a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
                );
              }
            }
          }
          this.mentionsData.mentions.sort(
            (a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
          );
        } catch (e) {
          console.warn("Failed to merge mentions data, saving anyway:", e);
        }
      }
      const content = JSON.stringify(this.mentionsData, null, 2);
      const expectedHash = this.computeHash(content);
      for (let attempt = 1; attempt <= MAX_SAVE_RETRIES2; attempt++) {
        await this.app.vault.adapter.write(MENTIONS_FILE, content);
        try {
          const savedContent = await this.app.vault.adapter.read(MENTIONS_FILE);
          const savedHash = this.computeHash(savedContent);
          if (savedHash === expectedHash) {
            console.debug("[Collab-Mentions] Mentions saved and verified (attempt", attempt + ")");
            return;
          } else {
            console.warn(`[Collab-Mentions] Save verification failed (attempt ${attempt}/${MAX_SAVE_RETRIES2}), hash mismatch`);
          }
        } catch (verifyError) {
          console.warn(`[Collab-Mentions] Save verification failed (attempt ${attempt}/${MAX_SAVE_RETRIES2}):`, verifyError);
        }
        if (attempt < MAX_SAVE_RETRIES2) {
          await new Promise((resolve) => setTimeout(resolve, 100 * attempt));
        }
      }
      console.error("[Collab-Mentions] Failed to verify mentions save after", MAX_SAVE_RETRIES2, "attempts");
    } catch (error) {
      console.error("Failed to save mentions:", error);
    }
  }
  /**
   * Parse a line of text for @mentions
   */
  parseMentions(text) {
    const mentions = [];
    let match;
    this.mentionRegex.lastIndex = 0;
    while ((match = this.mentionRegex.exec(text)) !== null) {
      const mentionedName = match[1];
      console.debug("[Collab-Mentions] Found @mention:", mentionedName);
      const user = this.userManager.getUserByName(mentionedName);
      console.debug("[Collab-Mentions] User lookup result:", user ? user.vaultName : "NOT FOUND");
      if (user) {
        mentions.push(mentionedName);
      }
    }
    return mentions;
  }
  /**
   * Get context around a mention (the full line or surrounding text)
   */
  getContext(content, lineNumber) {
    const lines = content.split("\n");
    if (lineNumber >= 0 && lineNumber < lines.length) {
      return lines[lineNumber].trim();
    }
    return "";
  }
  /**
   * Create a new mention
   */
  async createMention(to, file, line, context) {
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser) {
      console.error("Cannot create mention: no current user");
      return null;
    }
    if (to.toLowerCase() === currentUser.vaultName.toLowerCase()) {
      console.debug("[Collab-Mentions] Skipping self-mention");
      return null;
    }
    const existingFromOther = this.mentionsData.mentions.find(
      (m) => m.to.toLowerCase() === to.toLowerCase() && m.file === file.path && m.line === line && m.from.toLowerCase() !== currentUser.vaultName.toLowerCase()
    );
    if (existingFromOther) {
      console.debug("[Collab-Mentions] Mention already exists from another user:", existingFromOther.from);
      return null;
    }
    const existingByLine = this.mentionsData.mentions.find(
      (m) => m.to.toLowerCase() === to.toLowerCase() && m.file === file.path && m.line === line && m.from.toLowerCase() === currentUser.vaultName.toLowerCase()
    );
    if (existingByLine) {
      if (existingByLine.context !== context) {
        existingByLine.context = context;
        await this.saveMentions();
      }
      return null;
    }
    const LINE_SHIFT_THRESHOLD = 10;
    const existingByContext = this.mentionsData.mentions.find(
      (m) => m.to.toLowerCase() === to.toLowerCase() && m.file === file.path && m.context === context && m.from.toLowerCase() === currentUser.vaultName.toLowerCase() && Math.abs(m.line - line) <= LINE_SHIFT_THRESHOLD
      // Only match if within threshold
    );
    if (existingByContext) {
      if (existingByContext.line !== line) {
        existingByContext.line = line;
        await this.saveMentions();
      }
      return null;
    }
    const mention = {
      id: this.generateId(),
      to,
      from: currentUser.vaultName,
      file: file.path,
      line,
      context,
      timestamp: new Date().toISOString(),
      read: false,
      replies: []
    };
    this.mentionsData.mentions.push(mention);
    await this.saveMentions();
    return mention;
  }
  /**
   * Process a file for new mentions (called on file modify)
   */
  async processFile(file) {
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return [];
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    const newMentions = [];
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const mentionedUsers = this.parseMentions(line);
      for (const userName of mentionedUsers) {
        if (userName.toLowerCase() === currentUser.vaultName.toLowerCase()) {
          continue;
        }
        const mention = await this.createMention(
          userName,
          file,
          i,
          line.trim()
        );
        if (mention) {
          newMentions.push(mention);
        }
      }
    }
    return newMentions;
  }
  /**
   * Get unread mentions for the current user
   */
  getUnreadMentions() {
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return [];
    return this.mentionsData.mentions.filter(
      (m) => m.to.toLowerCase() === currentUser.vaultName.toLowerCase() && !m.read
    );
  }
  /**
   * Get all mentions for the current user
   */
  getAllMentionsForCurrentUser() {
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return [];
    return this.mentionsData.mentions.filter(
      (m) => m.to.toLowerCase() === currentUser.vaultName.toLowerCase()
    ).sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
  }
  /**
   * Get all mentions from the current user
   */
  getMentionsFromCurrentUser() {
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return [];
    return this.mentionsData.mentions.filter(
      (m) => m.from.toLowerCase() === currentUser.vaultName.toLowerCase()
    ).sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
  }
  /**
   * Mark a mention as read
   */
  async markAsRead(mentionId) {
    const mention = this.mentionsData.mentions.find((m) => m.id === mentionId);
    if (mention && !mention.read) {
      mention.read = true;
      mention.readAt = new Date().toISOString();
      await this.saveMentions();
    }
  }
  /**
   * Mark all mentions as read for current user
   */
  async markAllAsRead() {
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return;
    const now = new Date().toISOString();
    this.mentionsData.mentions.forEach((m) => {
      if (m.to.toLowerCase() === currentUser.vaultName.toLowerCase() && !m.read) {
        m.read = true;
        m.readAt = now;
      }
    });
    await this.saveMentions();
  }
  /**
   * Add a reply to a mention
   */
  async addReply(mentionId, message) {
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return null;
    const mention = this.mentionsData.mentions.find((m) => m.id === mentionId);
    if (!mention)
      return null;
    if (!mention.replies) {
      mention.replies = [];
    }
    const reply = {
      id: this.generateId(),
      from: currentUser.vaultName,
      message,
      timestamp: new Date().toISOString()
    };
    mention.replies.push(reply);
    await this.saveMentions();
    return reply;
  }
  /**
   * Delete old read mentions (cleanup) - ALL mentions
   */
  async cleanupOldMentions(daysOld = 30) {
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - daysOld);
    const initialCount = this.mentionsData.mentions.length;
    this.mentionsData.mentions = this.mentionsData.mentions.filter((m) => {
      const mentionDate = new Date(m.timestamp);
      return !m.read || mentionDate > cutoff;
    });
    const removed = initialCount - this.mentionsData.mentions.length;
    if (removed > 0) {
      await this.saveMentions();
    }
    return removed;
  }
  /**
   * Cleanup mentions with scope options
   * @param scope - 'my-received' | 'my-sent' | 'user-received' | 'user-sent' | 'all'
   * @param targetUser - the user to cleanup for (current user or specified)
   * @param daysOld - how old mentions must be to be removed (0 = all read)
   */
  async cleanupMentionsScoped(scope, targetUser, daysOld = 30) {
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - daysOld);
    const initialCount = this.mentionsData.mentions.length;
    this.mentionsData.mentions = this.mentionsData.mentions.filter((m) => {
      const mentionDate = new Date(m.timestamp);
      const isOldEnough = daysOld === 0 || mentionDate <= cutoff;
      if (!m.read)
        return true;
      if (!isOldEnough)
        return true;
      switch (scope) {
        case "my-received":
        case "user-received":
          return m.to !== targetUser;
        case "my-sent":
        case "user-sent":
          return m.from !== targetUser;
        case "all":
          return false;
        default:
          return true;
      }
    });
    const removed = initialCount - this.mentionsData.mentions.length;
    if (removed > 0) {
      await this.saveMentions();
    }
    return removed;
  }
  /**
   * Get list of all users who have mentions (for cleanup UI)
   */
  getAllMentionedUsers() {
    const users = /* @__PURE__ */ new Set();
    for (const mention of this.mentionsData.mentions) {
      users.add(mention.to);
      users.add(mention.from);
    }
    return Array.from(users).sort();
  }
  /**
   * Get all mentions (for admin/debug)
   */
  getAllMentions() {
    return this.mentionsData.mentions;
  }
  /**
   * AUTO CLEANUP - Keep only last N mentions per user
   */
  async autoCleanupMentions(maxPerUser, cleanupIntervalHours) {
    const now = new Date();
    const lastCleanup = this.mentionsData.lastCleanup ? new Date(this.mentionsData.lastCleanup) : new Date(0);
    const hoursSinceCleanup = (now.getTime() - lastCleanup.getTime()) / (1e3 * 60 * 60);
    if (hoursSinceCleanup < cleanupIntervalHours) {
      return 0;
    }
    const initialCount = this.mentionsData.mentions.length;
    const mentionsByUser = {};
    for (const mention of this.mentionsData.mentions) {
      if (!mentionsByUser[mention.to]) {
        mentionsByUser[mention.to] = [];
      }
      mentionsByUser[mention.to].push(mention);
    }
    const kept = [];
    for (const userName in mentionsByUser) {
      const userMentions = mentionsByUser[userName];
      userMentions.sort(
        (a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
      );
      const unread = userMentions.filter((m) => !m.read);
      const read = userMentions.filter((m) => m.read);
      kept.push(...unread);
      kept.push(...read.slice(0, Math.max(0, maxPerUser - unread.length)));
    }
    this.mentionsData.mentions = kept;
    this.mentionsData.lastCleanup = now.toISOString();
    const removed = initialCount - kept.length;
    if (removed > 0) {
      await this.saveMentions();
      console.debug(`Auto-cleanup: removed ${removed} old mentions`);
    }
    return removed;
  }
  /**
   * Get file path for watching
   */
  getMentionsFilePath() {
    return MENTIONS_FILE;
  }
  /**
   * Get all mention IDs (for cleanup of notification tracking)
   */
  getAllMentionIds() {
    return this.mentionsData.mentions.map((m) => m.id);
  }
};

// src/chatManager.ts
var CHAT_FILE = ".collab-mentions/chat.json";
var IMAGES_FOLDER = ".collab-mentions/images";
var MAX_MESSAGES_PER_CHANNEL = 200;
var MAX_SAVE_RETRIES3 = 3;
var MAX_LOAD_RETRIES = 3;
var DELETED_CHANNEL_RETENTION_MS = 24 * 60 * 60 * 1e3;
var _ChatManager = class {
  // 60 seconds protection
  constructor(app, userManager) {
    this.activeChannelId = GENERAL_CHANNEL_ID;
    // Safeguard: Track recently sent messages to prevent loss during sync conflicts
    this.recentlySentMessages = /* @__PURE__ */ new Map();
    this.MESSAGE_PROTECTION_DURATION = 6e4;
    // Protect messages for 60 seconds
    // Track recently dismissed messages to prevent them from being re-added during merge
    this.recentlyDismissedMessages = /* @__PURE__ */ new Map();
    this.DISMISS_PROTECTION_DURATION = 6e4;
    // Prevent re-add for 60 seconds
    // Track recently deleted channels to prevent re-add during sync
    this.recentlyDeletedChannels = /* @__PURE__ */ new Map();
    this.CHANNEL_DELETE_PROTECTION = 3e5;
    // 5 minutes protection
    // Track channels the current user recently left to prevent re-adding during merge
    this.recentlyLeftChannels = /* @__PURE__ */ new Map();
    this.LEAVE_PROTECTION_DURATION = 3e5;
    // 5 minutes protection
    // Track recently added members to prevent removal during merge conflicts
    // Key: channelId, Value: Map<username, timestamp>
    this.recentlyAddedMembers = /* @__PURE__ */ new Map();
    this.ADD_MEMBER_PROTECTION_DURATION = 3e5;
    // 5 minutes protection
    // Track recently toggled reactions to properly sync removals
    // Key: messageId, Value: Map<"emoji|username" -> { added: boolean, timestamp: number }>
    this.recentlyToggledReactions = /* @__PURE__ */ new Map();
    this.REACTION_TOGGLE_PROTECTION_DURATION = 6e4;
    this.app = app;
    this.userManager = userManager;
    this.chatData = this.createEmptyV2Data();
  }
  /**
   * Fast non-cryptographic hash (FNV-1a) for verification and deduplication
   * Much faster than SHA-256 - optimized for speed, not security
   */
  computeHash(content) {
    let hash = 2166136261;
    for (let i = 0; i < content.length; i++) {
      hash ^= content.charCodeAt(i);
      hash = hash * 16777619 >>> 0;
    }
    return hash.toString(16);
  }
  /**
   * Compute checksum for data integrity validation (excluding the _checksum field itself)
   */
  computeDataChecksum(data) {
    const dataWithoutChecksum = { ...data };
    delete dataWithoutChecksum._checksum;
    return this.computeHash(JSON.stringify(dataWithoutChecksum));
  }
  /**
   * Validate file integrity by checking the checksum
   * Returns true if valid, false if corrupted/incomplete
   */
  validateDataIntegrity(data) {
    if (!data._checksum) {
      return true;
    }
    const expectedChecksum = this.computeDataChecksum(data);
    const valid = data._checksum === expectedChecksum;
    if (!valid) {
      console.warn("[Collab-Mentions] Checksum mismatch - file may be corrupted or incomplete");
    }
    return valid;
  }
  /**
   * Generate a content-based hash for a chat message (for notification deduplication)
   * Includes images in the hash to properly dedupe image-only messages
   */
  getMessageContentHash(message) {
    const imageIds = message.images ? message.images.map((i) => i.id).join(",") : "";
    const content = `${message.from}|${message.message}|${message.timestamp}|${imageIds}`;
    return this.computeHash(content);
  }
  /**
   * Check if a message was recently dismissed and should not be re-added
   */
  isRecentlyDismissed(messageId) {
    const dismissedTime = this.recentlyDismissedMessages.get(messageId);
    if (!dismissedTime)
      return false;
    const now = Date.now();
    if (now - dismissedTime > this.DISMISS_PROTECTION_DURATION) {
      this.recentlyDismissedMessages.delete(messageId);
      return false;
    }
    return true;
  }
  /**
   * Merge updates from disk message into our in-memory message
   * Handles reactions, edits, and deletions
   *
   * MERGE STRATEGY:
   * - Reactions: ADDITIVE merge (combine all unique emoji+user pairs from both)
   *   BUT respects recent toggles - if current user recently removed a reaction,
   *   it won't be re-added from disk during the protection window.
   * - Edits: Disk wins if disk shows edited and we don't (disk is newer)
   * - Deletions: Disk wins if disk shows deleted (deletions are authoritative)
   */
  mergeMessageUpdates(ourMsg, diskMsg) {
    const mergedReactions = [];
    const emojiMap = /* @__PURE__ */ new Map();
    if (ourMsg.reactions) {
      for (const reaction of ourMsg.reactions) {
        if (!emojiMap.has(reaction.emoji)) {
          emojiMap.set(reaction.emoji, /* @__PURE__ */ new Set());
        }
        for (const user of reaction.users) {
          emojiMap.get(reaction.emoji).add(user);
        }
      }
    }
    if (diskMsg.reactions) {
      for (const reaction of diskMsg.reactions) {
        if (!emojiMap.has(reaction.emoji)) {
          emojiMap.set(reaction.emoji, /* @__PURE__ */ new Set());
        }
        for (const user of reaction.users) {
          const recentToggle = this.getRecentReactionToggle(ourMsg.id, reaction.emoji, user);
          if (recentToggle && !recentToggle.added) {
            console.debug(`[Collab-Mentions] Merge: Skipping re-add of ${reaction.emoji} by ${user} (recently removed)`);
            continue;
          }
          emojiMap.get(reaction.emoji).add(user);
        }
      }
    }
    const msgToggles = this.recentlyToggledReactions.get(ourMsg.id);
    if (msgToggles) {
      const now = Date.now();
      for (const [key, toggle] of msgToggles) {
        if (now - toggle.timestamp > this.REACTION_TOGGLE_PROTECTION_DURATION) {
          msgToggles.delete(key);
          continue;
        }
        if (toggle.added) {
          const [emoji, username] = key.split("|");
          if (!emojiMap.has(emoji)) {
            emojiMap.set(emoji, /* @__PURE__ */ new Set());
          }
          emojiMap.get(emoji).add(username);
        }
      }
    }
    for (const [emoji, users] of emojiMap) {
      if (users.size > 0) {
        mergedReactions.push({
          emoji,
          users: Array.from(users)
        });
      }
    }
    if (diskMsg.reactions === void 0 && ourMsg.reactions && ourMsg.reactions.length > 0) {
      if (diskMsg.deleted || diskMsg.editedAt && ourMsg.editedAt && new Date(diskMsg.editedAt) > new Date(ourMsg.editedAt)) {
        ourMsg.reactions = void 0;
      } else {
        ourMsg.reactions = mergedReactions.length > 0 ? mergedReactions : void 0;
      }
    } else {
      ourMsg.reactions = mergedReactions.length > 0 ? mergedReactions : void 0;
    }
    if (diskMsg.edited) {
      if (!ourMsg.edited) {
        ourMsg.edited = diskMsg.edited;
        ourMsg.editedAt = diskMsg.editedAt;
        ourMsg.message = diskMsg.message;
        ourMsg.mentions = diskMsg.mentions;
        ourMsg.fileLinks = diskMsg.fileLinks;
        ourMsg.channelMentions = diskMsg.channelMentions;
      } else if (diskMsg.editedAt && ourMsg.editedAt) {
        if (new Date(diskMsg.editedAt) > new Date(ourMsg.editedAt)) {
          ourMsg.editedAt = diskMsg.editedAt;
          ourMsg.message = diskMsg.message;
          ourMsg.mentions = diskMsg.mentions;
          ourMsg.fileLinks = diskMsg.fileLinks;
          ourMsg.channelMentions = diskMsg.channelMentions;
        }
      }
    }
    if (diskMsg.deleted && !ourMsg.deleted) {
      ourMsg.deleted = diskMsg.deleted;
      ourMsg.message = "";
      ourMsg.images = void 0;
      ourMsg.fileLinks = void 0;
      ourMsg.mentions = void 0;
      ourMsg.channelMentions = void 0;
      ourMsg.reactions = void 0;
    }
  }
  /**
   * Ensure recently sent messages are not lost after load operations
   */
  ensureRecentMessagesExist() {
    const now = Date.now();
    for (const [msgId, entry] of this.recentlySentMessages.entries()) {
      if (now - entry.timestamp > this.MESSAGE_PROTECTION_DURATION) {
        this.recentlySentMessages.delete(msgId);
        continue;
      }
      if (!this.chatData.channelMessages[entry.channelId]) {
        this.chatData.channelMessages[entry.channelId] = [];
      }
      const exists = this.chatData.channelMessages[entry.channelId].some((m) => m.id === msgId);
      if (!exists) {
        console.debug(`Re-adding protected message ${msgId} that was lost during sync`);
        this.chatData.channelMessages[entry.channelId].push(entry.message);
        this.chatData.channelMessages[entry.channelId].sort(
          (a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
        );
      }
    }
  }
  /**
   * Create empty V2 data structure with General channel
   */
  createEmptyV2Data() {
    return {
      version: 2,
      channels: [{
        id: GENERAL_CHANNEL_ID,
        type: "general",
        name: "General",
        members: [],
        createdBy: "system",
        createdAt: new Date().toISOString()
      }],
      channelMessages: {
        [GENERAL_CHANNEL_ID]: []
      },
      readState: {
        [GENERAL_CHANNEL_ID]: {}
      },
      deletedChannels: []
    };
  }
  /**
   * Migrate V1 data to V2 format
   */
  migrateV1ToV2(v1Data) {
    const v2Data = this.createEmptyV2Data();
    v2Data.channelMessages[GENERAL_CHANNEL_ID] = v1Data.messages || [];
    if (v1Data.lastReadTimestamp) {
      v2Data.readState[GENERAL_CHANNEL_ID] = { ...v1Data.lastReadTimestamp };
    }
    return v2Data;
  }
  /**
   * Check if data is V2 format
   */
  isV2Data(data) {
    return data.version === 2;
  }
  /**
   * Generate a simple unique ID
   */
  generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2, 11);
  }
  /**
   * Load chat data from vault with merge strategy to preserve in-memory changes
   * Includes retry logic for handling incomplete file syncs
   */
  async loadChat() {
    try {
      if (!await this.app.vault.adapter.exists(".collab-mentions")) {
        await this.app.vault.adapter.mkdir(".collab-mentions");
      }
      if (await this.app.vault.adapter.exists(CHAT_FILE)) {
        let rawData = null;
        let lastError = null;
        for (let attempt = 1; attempt <= MAX_LOAD_RETRIES; attempt++) {
          try {
            const content = await this.app.vault.adapter.read(CHAT_FILE);
            const parsed = JSON.parse(content);
            if (this.isV2Data(parsed) && !this.validateDataIntegrity(parsed)) {
              throw new Error("Checksum validation failed - file may be incomplete");
            }
            rawData = parsed;
            break;
          } catch (parseError) {
            lastError = parseError;
            console.warn(`[Collab-Mentions] Load attempt ${attempt}/${MAX_LOAD_RETRIES} failed:`, parseError);
            if (attempt < MAX_LOAD_RETRIES) {
              await new Promise((resolve) => setTimeout(resolve, 500 * attempt));
            }
          }
        }
        if (!rawData) {
          console.error("[Collab-Mentions] Failed to load chat after", MAX_LOAD_RETRIES, "attempts:", lastError);
          if (this.chatData && this.chatData.channels.length > 0) {
            console.debug("[Collab-Mentions] Keeping existing in-memory data");
            return;
          }
          this.chatData = this.createEmptyV2Data();
          return;
        }
        let diskData;
        if (this.isV2Data(rawData)) {
          diskData = rawData;
        } else {
          console.debug("Migrating chat data from V1 to V2...");
          diskData = this.migrateV1ToV2(rawData);
        }
        if (!this.chatData || this.chatData.channels.length === 0) {
          this.chatData = diskData;
          if (!this.isV2Data(rawData)) {
            await this.saveChat();
          }
          return;
        }
        if (!this.chatData.deletedChannels) {
          this.chatData.deletedChannels = [];
        }
        if (!diskData.deletedChannels) {
          diskData.deletedChannels = [];
        }
        const ourDeletedIds = new Set(this.chatData.deletedChannels.map((d) => d.id));
        for (const diskDeleted of diskData.deletedChannels) {
          if (!ourDeletedIds.has(diskDeleted.id)) {
            console.debug("[Collab-Mentions] Syncing deleted channel from disk:", diskDeleted.id);
            this.chatData.deletedChannels.push(diskDeleted);
            this.recentlyDeletedChannels.set(diskDeleted.id, new Date(diskDeleted.deletedAt).getTime());
          }
        }
        const now = Date.now();
        this.chatData.deletedChannels = this.chatData.deletedChannels.filter((d) => {
          const age = now - new Date(d.deletedAt).getTime();
          return age < DELETED_CHANNEL_RETENTION_MS;
        });
        const diskChannelIds = new Set(diskData.channels.map((ch) => ch.id));
        const deletedChannelIds = new Set((this.chatData.deletedChannels || []).map((d) => d.id));
        const channelsToRemove = this.chatData.channels.filter((ch) => {
          if (ch.id === GENERAL_CHANNEL_ID)
            return false;
          const notOnDisk = !diskChannelIds.has(ch.id);
          const explicitlyDeleted = deletedChannelIds.has(ch.id);
          return notOnDisk && explicitlyDeleted;
        });
        for (const ch of channelsToRemove) {
          console.debug("[Collab-Mentions] Removing explicitly deleted channel:", ch.id, ch.name);
          this.chatData.channels = this.chatData.channels.filter((c) => c.id !== ch.id);
          delete this.chatData.channelMessages[ch.id];
          delete this.chatData.readState[ch.id];
        }
        const localOnlyChannels = this.chatData.channels.filter(
          (ch) => ch.id !== GENERAL_CHANNEL_ID && !diskChannelIds.has(ch.id) && !deletedChannelIds.has(ch.id)
        );
        if (localOnlyChannels.length > 0) {
          console.debug(
            "[Collab-Mentions] Preserving local-only channels (will sync back):",
            localOnlyChannels.map((c) => ({ id: c.id, name: c.name }))
          );
        }
        const ourChannelMap = new Map(this.chatData.channels.map((ch) => [ch.id, ch]));
        for (const diskChannel of diskData.channels) {
          if (this.isRecentlyDeletedChannel(diskChannel.id)) {
            console.debug("[Collab-Mentions] Skipping recently deleted channel:", diskChannel.id);
            continue;
          }
          const ourChannel = ourChannelMap.get(diskChannel.id);
          if (!ourChannel) {
            const currentUser = this.userManager.getCurrentUser();
            if (currentUser && this.hasRecentlyLeftChannel(diskChannel.id)) {
              diskChannel.members = diskChannel.members.filter((m) => m !== currentUser.vaultName);
              console.debug("[Collab-Mentions] Adding new channel from disk (filtered after recent leave):", diskChannel.id, diskChannel.name);
            } else {
              console.debug("[Collab-Mentions] Adding new channel from disk:", diskChannel.id, diskChannel.name);
            }
            const recentlyAdded = this.getRecentlyAddedMembers(diskChannel.id);
            for (const member of recentlyAdded) {
              if (!diskChannel.members.includes(member)) {
                diskChannel.members.push(member);
                console.debug("[Collab-Mentions] Preserved recently added member in new channel:", member);
              }
            }
            this.chatData.channels.push(diskChannel);
          } else {
            console.debug(
              "[Collab-Mentions] Merging channel:",
              ourChannel.id,
              "our members:",
              ourChannel.members,
              "disk members:",
              diskChannel.members
            );
            const currentUser = this.userManager.getCurrentUser();
            let mergedMembers = [...diskChannel.members];
            if (currentUser && this.hasRecentlyLeftChannel(diskChannel.id)) {
              const wasInDiskMembers = mergedMembers.includes(currentUser.vaultName);
              mergedMembers = mergedMembers.filter((m) => m !== currentUser.vaultName);
              if (wasInDiskMembers) {
                console.debug("[Collab-Mentions] Prevented re-adding user after recent leave:", currentUser.vaultName);
              }
            }
            const recentlyAdded = this.getRecentlyAddedMembers(diskChannel.id);
            for (const member of recentlyAdded) {
              if (!mergedMembers.includes(member)) {
                mergedMembers.push(member);
                console.debug("[Collab-Mentions] Preserved recently added member:", member);
              }
            }
            ourChannel.members = mergedMembers;
            if (diskChannel.name !== ourChannel.name && diskChannel.type === "group") {
              ourChannel.name = diskChannel.name;
            }
          }
        }
        for (const channelId of Object.keys(diskData.channelMessages)) {
          if (!this.chatData.channelMessages[channelId]) {
            this.chatData.channelMessages[channelId] = diskData.channelMessages[channelId].filter(
              (m) => !this.isRecentlyDismissed(m.id)
            );
          } else {
            const ourMessageMap = new Map(
              this.chatData.channelMessages[channelId].map((m) => [m.id, m])
            );
            for (const diskMsg of diskData.channelMessages[channelId]) {
              if (this.isRecentlyDismissed(diskMsg.id))
                continue;
              const ourMsg = ourMessageMap.get(diskMsg.id);
              if (!ourMsg) {
                this.chatData.channelMessages[channelId].push(diskMsg);
              } else {
                this.mergeMessageUpdates(ourMsg, diskMsg);
              }
            }
            this.chatData.channelMessages[channelId].sort(
              (a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
            );
          }
        }
        for (const channelId of Object.keys(this.chatData.channelMessages)) {
          if (!diskData.channelMessages[channelId]) {
            continue;
          }
        }
        for (const channelId of Object.keys(diskData.readState)) {
          if (!this.chatData.readState[channelId]) {
            this.chatData.readState[channelId] = diskData.readState[channelId];
          } else {
            for (const username of Object.keys(diskData.readState[channelId])) {
              const diskTimestamp = diskData.readState[channelId][username];
              const ourTimestamp = this.chatData.readState[channelId][username];
              if (!ourTimestamp || new Date(diskTimestamp) > new Date(ourTimestamp)) {
                this.chatData.readState[channelId][username] = diskTimestamp;
              }
            }
          }
        }
        if (diskData.mutedChannels) {
          if (!this.chatData.mutedChannels) {
            this.chatData.mutedChannels = {};
          }
          for (const username of Object.keys(diskData.mutedChannels)) {
            if (!this.chatData.mutedChannels[username]) {
              this.chatData.mutedChannels[username] = diskData.mutedChannels[username];
            } else {
              const combined = /* @__PURE__ */ new Set([
                ...this.chatData.mutedChannels[username],
                ...diskData.mutedChannels[username]
              ]);
              this.chatData.mutedChannels[username] = Array.from(combined);
            }
          }
        }
      } else {
        this.chatData = this.createEmptyV2Data();
        await this.saveChat();
      }
      this.ensureRecentMessagesExist();
    } catch (error) {
      console.error("Failed to load chat:", error);
      if (!this.chatData) {
        this.chatData = this.createEmptyV2Data();
      }
      this.ensureRecentMessagesExist();
    }
  }
  /**
   * Save chat data to vault with merge strategy to prevent data loss
   */
  async saveChat() {
    try {
      if (await this.app.vault.adapter.exists(CHAT_FILE)) {
        try {
          const diskContent = await this.app.vault.adapter.read(CHAT_FILE);
          const diskData = JSON.parse(diskContent);
          if (this.isV2Data(diskData)) {
            for (const channelId of Object.keys(diskData.channelMessages)) {
              if (!this.chatData.channelMessages[channelId]) {
                this.chatData.channelMessages[channelId] = diskData.channelMessages[channelId];
              } else {
                const ourMessageMap = new Map(
                  this.chatData.channelMessages[channelId].map((m) => [m.id, m])
                );
                for (const diskMsg of diskData.channelMessages[channelId]) {
                  const ourMsg = ourMessageMap.get(diskMsg.id);
                  if (!ourMsg) {
                    this.chatData.channelMessages[channelId].push(diskMsg);
                  } else {
                    this.mergeMessageUpdates(ourMsg, diskMsg);
                  }
                }
                this.chatData.channelMessages[channelId].sort(
                  (a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
                );
              }
            }
            for (const channelId of Object.keys(diskData.readState)) {
              if (!this.chatData.readState[channelId]) {
                this.chatData.readState[channelId] = diskData.readState[channelId];
              } else {
                for (const username of Object.keys(diskData.readState[channelId])) {
                  const diskTimestamp = diskData.readState[channelId][username];
                  const ourTimestamp = this.chatData.readState[channelId][username];
                  if (!ourTimestamp || new Date(diskTimestamp) > new Date(ourTimestamp)) {
                    this.chatData.readState[channelId][username] = diskTimestamp;
                  }
                }
              }
            }
            if (diskData.deletedChannels) {
              if (!this.chatData.deletedChannels) {
                this.chatData.deletedChannels = [];
              }
              const ourDeletedIds = new Set(this.chatData.deletedChannels.map((d) => d.id));
              for (const diskDeleted of diskData.deletedChannels) {
                if (!ourDeletedIds.has(diskDeleted.id)) {
                  this.chatData.deletedChannels.push(diskDeleted);
                }
              }
            }
            if (diskData.mutedChannels) {
              if (!this.chatData.mutedChannels) {
                this.chatData.mutedChannels = {};
              }
              for (const username of Object.keys(diskData.mutedChannels)) {
                if (!this.chatData.mutedChannels[username]) {
                  this.chatData.mutedChannels[username] = diskData.mutedChannels[username];
                } else {
                  const combined = /* @__PURE__ */ new Set([
                    ...this.chatData.mutedChannels[username],
                    ...diskData.mutedChannels[username]
                  ]);
                  this.chatData.mutedChannels[username] = Array.from(combined);
                }
              }
            }
          }
        } catch (e) {
          console.warn("Failed to merge chat data, saving anyway:", e);
        }
      }
      this.ensureRecentMessagesExist();
      if (!this.chatData.deletedChannels) {
        this.chatData.deletedChannels = [];
      }
      delete this.chatData._checksum;
      this.chatData._checksum = this.computeDataChecksum(this.chatData);
      const content = JSON.stringify(this.chatData, null, 2);
      const expectedHash = this.computeHash(content);
      for (let attempt = 1; attempt <= MAX_SAVE_RETRIES3; attempt++) {
        await this.app.vault.adapter.write(CHAT_FILE, content);
        try {
          const savedContent = await this.app.vault.adapter.read(CHAT_FILE);
          const savedHash = this.computeHash(savedContent);
          if (savedHash === expectedHash) {
            console.debug("[Collab-Mentions] Chat saved and verified (attempt", attempt + ")");
            return;
          } else {
            console.warn(`[Collab-Mentions] Chat save verification failed (attempt ${attempt}/${MAX_SAVE_RETRIES3}), hash mismatch`);
          }
        } catch (verifyError) {
          console.warn(`[Collab-Mentions] Chat save verification failed (attempt ${attempt}/${MAX_SAVE_RETRIES3}):`, verifyError);
        }
        if (attempt < MAX_SAVE_RETRIES3) {
          await new Promise((resolve) => setTimeout(resolve, 100 * attempt));
        }
      }
      console.error("[Collab-Mentions] Failed to verify chat save after", MAX_SAVE_RETRIES3, "attempts");
    } catch (error) {
      console.error("Failed to save chat:", error);
    }
  }
  // ==================== Channel Management ====================
  /**
   * Get the active channel ID
   */
  getActiveChannelId() {
    return this.activeChannelId;
  }
  /**
   * Set the active channel
   */
  setActiveChannel(channelId) {
    if (this.chatData.channels.some((c) => c.id === channelId)) {
      this.activeChannelId = channelId;
    }
  }
  /**
   * Get a channel by ID
   */
  getChannel(channelId) {
    return this.chatData.channels.find((c) => c.id === channelId);
  }
  /**
   * Get all channels visible to a user
   */
  getChannelsForUser(username) {
    return this.chatData.channels.filter((channel) => {
      if (channel.type === "general")
        return true;
      return channel.members.includes(username);
    });
  }
  /**
   * Get all channels (for admin purposes)
   */
  getAllChannels() {
    return this.chatData.channels;
  }
  /**
   * Create a new group channel
   */
  async createGroupChannel(name, members, createdBy) {
    const uniqueMembers = [...new Set(members)];
    const channel = {
      id: this.generateId(),
      type: "group",
      name: name.trim(),
      members: uniqueMembers,
      createdBy,
      createdAt: new Date().toISOString()
    };
    this.chatData.channels.push(channel);
    this.chatData.channelMessages[channel.id] = [];
    this.chatData.readState[channel.id] = {};
    for (const member of uniqueMembers) {
      this.trackMemberAdded(channel.id, member);
    }
    await this.saveChat();
    return channel;
  }
  /**
   * Start or get existing DM between two users
   */
  async startDM(initiator, recipient) {
    const existingDM = this.chatData.channels.find(
      (ch) => ch.type === "dm" && ch.members.length === 2 && ch.members.includes(initiator) && ch.members.includes(recipient)
    );
    if (existingDM)
      return existingDM;
    const channel = {
      id: this.generateId(),
      type: "dm",
      name: "",
      // DMs don't have names, UI shows other participant
      members: [initiator, recipient],
      createdBy: initiator,
      createdAt: new Date().toISOString()
    };
    this.chatData.channels.push(channel);
    this.chatData.channelMessages[channel.id] = [];
    this.chatData.readState[channel.id] = {};
    this.trackMemberAdded(channel.id, initiator);
    this.trackMemberAdded(channel.id, recipient);
    await this.saveChat();
    return channel;
  }
  /**
   * Add member to a channel (DM converts to group if adding third person)
   */
  async addMemberToChannel(channelId, newMember, addedBy) {
    const channel = this.chatData.channels.find((ch) => ch.id === channelId);
    if (!channel)
      return false;
    if (channel.type === "general")
      return false;
    if (channel.members.includes(newMember))
      return true;
    const currentUser = this.userManager.getCurrentUser();
    if (currentUser && newMember === currentUser.vaultName) {
      this.recentlyLeftChannels.delete(channelId);
      console.debug("[Collab-Mentions] Cleared leave protection - user explicitly rejoined");
    }
    if (channel.type === "dm") {
      channel.type = "group";
      channel.name = channel.members.join(", ");
    }
    channel.members.push(newMember);
    this.trackMemberAdded(channelId, newMember);
    const systemMsg = {
      id: this.generateId(),
      from: "system",
      message: `${addedBy} added ${newMember} to the conversation`,
      timestamp: new Date().toISOString()
    };
    this.chatData.channelMessages[channelId].push(systemMsg);
    await this.saveChat();
    return true;
  }
  /**
   * Check if user is the last member of a channel
   */
  isLastMember(channelId, username) {
    const channel = this.chatData.channels.find((ch) => ch.id === channelId);
    if (!channel)
      return false;
    return channel.members.length === 1 && channel.members[0] === username;
  }
  /**
   * Leave a channel. Returns 'left' if successful, 'deleted' if channel was deleted (last member), false if failed.
   * Note: If user is last member, the channel is automatically deleted after they leave.
   */
  async leaveChannel(channelId, username) {
    const channel = this.chatData.channels.find((ch) => ch.id === channelId);
    if (!channel) {
      console.debug("[Collab-Mentions] leaveChannel: channel not found", channelId);
      return false;
    }
    if (channel.type === "general")
      return false;
    const wasLastMember = this.isLastMember(channelId, username);
    console.debug("[Collab-Mentions] leaveChannel:", channelId, "user:", username, "members before:", channel.members, "isLastMember:", wasLastMember);
    channel.members = channel.members.filter((m) => m !== username);
    this.recentlyLeftChannels.set(channelId, Date.now());
    const channelAddedMembers = this.recentlyAddedMembers.get(channelId);
    if (channelAddedMembers) {
      channelAddedMembers.delete(username);
      console.debug("[Collab-Mentions] leaveChannel: cleared add protection for", username);
    }
    console.debug("[Collab-Mentions] leaveChannel: tracking leave for merge protection");
    console.debug("[Collab-Mentions] leaveChannel: members after:", channel.members);
    if (this.activeChannelId === channelId) {
      this.activeChannelId = GENERAL_CHANNEL_ID;
    }
    if (channel.members.length === 0) {
      console.debug("[Collab-Mentions] leaveChannel: channel now empty, deleting");
      await this.deleteChannel(channelId);
      return "deleted";
    }
    const systemMsg = {
      id: this.generateId(),
      from: "system",
      message: `${username} left the conversation`,
      timestamp: new Date().toISOString()
    };
    this.chatData.channelMessages[channelId].push(systemMsg);
    await this.saveChat();
    return "left";
  }
  /**
   * Delete a channel entirely (only creator or last member can delete)
   */
  async deleteChannel(channelId) {
    if (channelId === GENERAL_CHANNEL_ID)
      return false;
    const currentUser = this.userManager.getCurrentUser();
    const deletedBy = (currentUser == null ? void 0 : currentUser.vaultName) || "unknown";
    console.debug("[Collab-Mentions] deleteChannel:", channelId, "by:", deletedBy, "channels before:", this.chatData.channels.length);
    const now = Date.now();
    this.recentlyDeletedChannels.set(channelId, now);
    if (!this.chatData.deletedChannels) {
      this.chatData.deletedChannels = [];
    }
    if (!this.chatData.deletedChannels.some((d) => d.id === channelId)) {
      this.chatData.deletedChannels.push({
        id: channelId,
        deletedAt: new Date().toISOString(),
        deletedBy
      });
      console.debug("[Collab-Mentions] Added to deletedChannels for sync");
    }
    this.chatData.channels = this.chatData.channels.filter((ch) => ch.id !== channelId);
    console.debug("[Collab-Mentions] deleteChannel: channels after:", this.chatData.channels.length);
    delete this.chatData.channelMessages[channelId];
    delete this.chatData.readState[channelId];
    if (this.activeChannelId === channelId) {
      this.activeChannelId = GENERAL_CHANNEL_ID;
    }
    await this.saveChat();
    console.debug("[Collab-Mentions] deleteChannel: saved");
    return true;
  }
  /**
   * Export a channel's messages to a markdown file
   * Creates a "collab-mentions" folder and saves as channelname_YYYY-MM-DD_HH-MM-SS.md
   * Also copies images to a dedicated images folder for the export
   * @returns The path to the exported file, or null if export failed
   */
  async exportChannel(channelId) {
    const channel = this.chatData.channels.find((ch) => ch.id === channelId);
    if (!channel)
      return null;
    const messages = this.chatData.channelMessages[channelId] || [];
    if (messages.length === 0)
      return null;
    try {
      const exportFolder = "collab-mentions";
      if (!await this.app.vault.adapter.exists(exportFolder)) {
        await this.app.vault.adapter.mkdir(exportFolder);
      }
      const now = new Date();
      const timestamp = now.toISOString().replace(/[:.]/g, "-").replace("T", "_").slice(0, 19);
      let channelName = channel.name || channel.id;
      if (channel.type === "dm") {
        channelName = `DM_${channel.members.join("_")}`;
      }
      channelName = channelName.replace(/[<>:"/\\|?*]/g, "_");
      const filename = `${channelName}_${timestamp}.md`;
      const filePath = `${exportFolder}/${filename}`;
      const allImages = [];
      const hasImages = messages.some((m) => m.images && m.images.length > 0);
      let imagesExportFolder = "";
      if (hasImages) {
        imagesExportFolder = `${exportFolder}/exported-images`;
        if (!await this.app.vault.adapter.exists(imagesExportFolder)) {
          await this.app.vault.adapter.mkdir(imagesExportFolder);
        }
        for (const msg of messages) {
          if (msg.images && msg.images.length > 0) {
            for (const img of msg.images) {
              if (await this.app.vault.adapter.exists(img.path)) {
                const exportedFilename = `${channelName}_${img.filename}`;
                const exportedPath = `${imagesExportFolder}/${exportedFilename}`;
                try {
                  const imageData = await this.app.vault.adapter.readBinary(img.path);
                  await this.app.vault.adapter.writeBinary(exportedPath, imageData);
                  allImages.push({
                    original: img.path,
                    exported: exportedPath,
                    filename: exportedFilename
                  });
                  console.debug("[Collab-Mentions] Exported image:", img.path, "->", exportedPath);
                } catch (imgError) {
                  console.warn("[Collab-Mentions] Failed to copy image:", img.path, imgError);
                }
              } else {
                console.warn("[Collab-Mentions] Image not found:", img.path);
              }
            }
          }
        }
      }
      const imagePathMap = new Map(allImages.map((i) => [i.original, i.exported]));
      let content = `# Chat Export: ${channel.name || channel.id}

`;
      content += `**Type:** ${channel.type}
`;
      content += `**Created by:** ${channel.createdBy}
`;
      content += `**Created at:** ${new Date(channel.createdAt).toLocaleString()}
`;
      content += `**Exported at:** ${now.toLocaleString()}
`;
      if (channel.members.length > 0) {
        content += `**Members:** ${channel.members.join(", ")}
`;
      }
      content += `**Total messages:** ${messages.length}
`;
      if (allImages.length > 0) {
        content += `**Images exported:** ${allImages.length}
`;
      }
      content += `
---

`;
      for (const msg of messages) {
        if (msg.deleted) {
          content += `**[${new Date(msg.timestamp).toLocaleString()}] ${msg.from}:** *(message deleted)*

`;
          continue;
        }
        const time = new Date(msg.timestamp).toLocaleString();
        const edited = msg.edited ? " *(edited)*" : "";
        if (msg.from === "system") {
          content += `*[${time}] ${msg.message}*

`;
        } else {
          content += `**[${time}] ${msg.from}:**${edited}
`;
          if (msg.message) {
            content += `${msg.message}
`;
          }
          if (msg.fileLinks && msg.fileLinks.length > 0) {
            content += `
Linked files: ${msg.fileLinks.map((f) => `[[${f}]]`).join(", ")}
`;
          }
          if (msg.images && msg.images.length > 0) {
            const imageRefs = msg.images.map((i) => {
              const exportedPath = imagePathMap.get(i.path);
              if (exportedPath) {
                return `![[${exportedPath}]]`;
              } else {
                return `![[${i.path}]] *(original)*`;
              }
            });
            content += `
${imageRefs.join(" ")}
`;
          }
          if (msg.reactions && msg.reactions.length > 0) {
            const reactions = msg.reactions.map((r) => `${r.emoji} (${r.users.join(", ")})`).join(" ");
            content += `
Reactions: ${reactions}
`;
          }
          content += `
`;
        }
      }
      await this.app.vault.adapter.write(filePath, content);
      console.debug("[Collab-Mentions] Exported channel to:", filePath);
      return filePath;
    } catch (error) {
      console.error("[Collab-Mentions] Failed to export channel:", error);
      return null;
    }
  }
  /**
   * Track that a member was recently added to a channel
   */
  trackMemberAdded(channelId, username) {
    if (!this.recentlyAddedMembers.has(channelId)) {
      this.recentlyAddedMembers.set(channelId, /* @__PURE__ */ new Map());
    }
    this.recentlyAddedMembers.get(channelId).set(username, Date.now());
    console.debug("[Collab-Mentions] Tracking member added for merge protection:", username, "to", channelId);
  }
  /**
   * Get recently added members for a channel that should be preserved during merge
   */
  getRecentlyAddedMembers(channelId) {
    const channelMembers = this.recentlyAddedMembers.get(channelId);
    if (!channelMembers)
      return [];
    const now = Date.now();
    const recentMembers = [];
    for (const [username, addedTime] of channelMembers) {
      const age = now - addedTime;
      if (age <= this.ADD_MEMBER_PROTECTION_DURATION) {
        recentMembers.push(username);
      } else {
        channelMembers.delete(username);
      }
    }
    return recentMembers;
  }
  /**
   * Check if the current user recently left a channel (should not be re-added during merge)
   */
  hasRecentlyLeftChannel(channelId) {
    const leftTime = this.recentlyLeftChannels.get(channelId);
    if (!leftTime)
      return false;
    const age = Date.now() - leftTime;
    if (age > this.LEAVE_PROTECTION_DURATION) {
      this.recentlyLeftChannels.delete(channelId);
      return false;
    }
    return true;
  }
  /**
   * Check if a channel was recently deleted (should not be re-added)
   * Checks both in-memory cache and persisted deletedChannels array
   */
  isRecentlyDeletedChannel(channelId) {
    const now = Date.now();
    const deletedTime = this.recentlyDeletedChannels.get(channelId);
    if (deletedTime) {
      const age = now - deletedTime;
      if (age <= this.CHANNEL_DELETE_PROTECTION) {
        return true;
      }
      this.recentlyDeletedChannels.delete(channelId);
    }
    if (this.chatData.deletedChannels) {
      const persistedDeletion = this.chatData.deletedChannels.find((d) => d.id === channelId);
      if (persistedDeletion) {
        const age = now - new Date(persistedDeletion.deletedAt).getTime();
        if (age <= DELETED_CHANNEL_RETENTION_MS) {
          this.recentlyDeletedChannels.set(channelId, new Date(persistedDeletion.deletedAt).getTime());
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Check if a user can delete a channel (must be creator or admin)
   */
  canDeleteChannel(channelId, username) {
    const channel = this.chatData.channels.find((ch) => ch.id === channelId);
    if (!channel)
      return false;
    if (channel.type === "general")
      return false;
    if (channel.createdBy === username)
      return true;
    return this.userManager.isUserAdmin(username);
  }
  /**
   * Delete a channel as admin (bypasses creator check)
   */
  async deleteChannelAsAdmin(channelId) {
    if (!this.userManager.isCurrentUserAdmin()) {
      return false;
    }
    return this.deleteChannel(channelId);
  }
  /**
   * Clean up stale channels (abandoned DMs)
   * - Removes DMs with 1 member (other person left) and no messages in last 7 days
   */
  async cleanupStaleChannels() {
    const now = Date.now();
    const sevenDaysMs = 7 * 24 * 60 * 60 * 1e3;
    let removedCount = 0;
    const channelsToRemove = [];
    for (const channel of this.chatData.channels) {
      if (channel.id === GENERAL_CHANNEL_ID)
        continue;
      if (channel.type === "dm" && channel.members.length === 1) {
        const messages = this.chatData.channelMessages[channel.id] || [];
        const lastMessage = messages[messages.length - 1];
        const lastActivity = lastMessage ? new Date(lastMessage.timestamp).getTime() : new Date(channel.createdAt).getTime();
        if (now - lastActivity > sevenDaysMs) {
          channelsToRemove.push(channel.id);
        }
      }
    }
    for (const channelId of channelsToRemove) {
      this.chatData.channels = this.chatData.channels.filter((ch) => ch.id !== channelId);
      delete this.chatData.channelMessages[channelId];
      delete this.chatData.readState[channelId];
      removedCount++;
    }
    if (removedCount > 0) {
      if (channelsToRemove.includes(this.activeChannelId)) {
        this.activeChannelId = GENERAL_CHANNEL_ID;
      }
      await this.saveChat();
    }
    return removedCount;
  }
  /**
   * Get a message by ID from a specific channel
   */
  getMessageById(messageId, channelId) {
    const targetChannel = channelId || this.activeChannelId;
    const messages = this.chatData.channelMessages[targetChannel] || [];
    return messages.find((m) => m.id === messageId);
  }
  // ==================== Mute Channels ====================
  /**
   * Check if a channel is muted for current user
   */
  isChannelMuted(channelId) {
    var _a;
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return false;
    const mutedChannels = ((_a = this.chatData.mutedChannels) == null ? void 0 : _a[currentUser.vaultName]) || [];
    return mutedChannels.includes(channelId);
  }
  /**
   * Toggle mute status for a channel
   */
  async toggleChannelMute(channelId) {
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return false;
    if (!this.chatData.mutedChannels) {
      this.chatData.mutedChannels = {};
    }
    if (!this.chatData.mutedChannels[currentUser.vaultName]) {
      this.chatData.mutedChannels[currentUser.vaultName] = [];
    }
    const mutedList = this.chatData.mutedChannels[currentUser.vaultName];
    const index = mutedList.indexOf(channelId);
    if (index === -1) {
      mutedList.push(channelId);
    } else {
      mutedList.splice(index, 1);
    }
    await this.saveChat();
    return this.isChannelMuted(channelId);
  }
  /**
   * Rename a channel (groups only)
   */
  async renameChannel(channelId, newName) {
    const channel = this.chatData.channels.find((ch) => ch.id === channelId);
    if (!channel)
      return false;
    if (channel.type !== "group")
      return false;
    channel.name = newName.trim();
    await this.saveChat();
    return true;
  }
  // ==================== Image Management ====================
  /**
   * Ensure images folder exists
   */
  async ensureImagesFolder() {
    if (!await this.app.vault.adapter.exists(IMAGES_FOLDER)) {
      await this.app.vault.adapter.mkdir(IMAGES_FOLDER);
    }
  }
  /**
   * Save an image to the vault and return the ChatImage object
   */
  async saveImage(file) {
    try {
      await this.ensureImagesFolder();
      const id = this.generateId();
      const extension = file.name.split(".").pop() || "png";
      const filename = `${id}.${extension}`;
      const path = `${IMAGES_FOLDER}/${filename}`;
      const arrayBuffer = await file.arrayBuffer();
      await this.app.vault.adapter.writeBinary(path, arrayBuffer);
      return { id, filename, path };
    } catch (error) {
      console.error("Failed to save image:", error);
      return null;
    }
  }
  /**
   * Save image from clipboard
   */
  async saveImageFromClipboard(blob) {
    try {
      await this.ensureImagesFolder();
      const id = this.generateId();
      const extension = blob.type.split("/")[1] || "png";
      const filename = `${id}.${extension}`;
      const path = `${IMAGES_FOLDER}/${filename}`;
      const arrayBuffer = await blob.arrayBuffer();
      await this.app.vault.adapter.writeBinary(path, arrayBuffer);
      return { id, filename, path };
    } catch (error) {
      console.error("Failed to save clipboard image:", error);
      return null;
    }
  }
  // ==================== Message Operations ====================
  /**
   * Send a message to a specific channel
   */
  async sendMessage(message, fileLinks, images, channelId, replyTo) {
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser) {
      console.error("Cannot send message: no current user");
      return null;
    }
    const targetChannel = channelId || this.activeChannelId;
    if (!this.chatData.channelMessages[targetChannel]) {
      this.chatData.channelMessages[targetChannel] = [];
    }
    const mentions = _ChatManager.extractMentions(message);
    const specialMentions = ["everyone"];
    const validMentions = mentions.filter(
      (m) => specialMentions.includes(m.toLowerCase()) || this.userManager.getUserByName(m) !== void 0
    );
    const channelMentionNames = _ChatManager.extractChannelMentions(message);
    const validChannelMentions = [];
    for (const channelName of channelMentionNames) {
      const channel = this.chatData.channels.find(
        (ch) => ch.name.toLowerCase() === channelName.toLowerCase()
      );
      if (channel) {
        validChannelMentions.push(channel.id);
      }
    }
    const chatMessage = {
      id: this.generateId(),
      from: currentUser.vaultName,
      message: message.trim(),
      timestamp: new Date().toISOString(),
      fileLinks: fileLinks && fileLinks.length > 0 ? fileLinks : void 0,
      mentions: validMentions.length > 0 ? validMentions : void 0,
      channelMentions: validChannelMentions.length > 0 ? validChannelMentions : void 0,
      images: images && images.length > 0 ? images : void 0,
      replyTo
    };
    this.recentlySentMessages.set(chatMessage.id, {
      channelId: targetChannel,
      message: chatMessage,
      timestamp: Date.now()
    });
    this.chatData.channelMessages[targetChannel].push(chatMessage);
    if (this.chatData.channelMessages[targetChannel].length > MAX_MESSAGES_PER_CHANNEL) {
      this.chatData.channelMessages[targetChannel] = this.chatData.channelMessages[targetChannel].slice(-MAX_MESSAGES_PER_CHANNEL);
    }
    await this.saveChat();
    return chatMessage;
  }
  /**
   * Dismiss/delete a system notification message (like file mention alerts)
   */
  async dismissSystemMessage(messageId, channelId) {
    const targetChannel = channelId || this.activeChannelId;
    const messages = this.chatData.channelMessages[targetChannel];
    if (!messages)
      return false;
    const messageIndex = messages.findIndex((m) => m.id === messageId);
    if (messageIndex === -1)
      return false;
    const message = messages[messageIndex];
    if (message.from !== "system")
      return false;
    this.recentlyDismissedMessages.set(messageId, Date.now());
    messages.splice(messageIndex, 1);
    await this.saveChat();
    return true;
  }
  /**
   * Find a channel by name or ID
   */
  getChannelByName(channelName) {
    const byId = this.chatData.channels.find(
      (ch) => ch.id.toLowerCase() === channelName.toLowerCase()
    );
    if (byId)
      return byId;
    return this.chatData.channels.find(
      (ch) => ch.name.toLowerCase() === channelName.toLowerCase()
    );
  }
  /**
   * Get messages for a specific channel (or active channel)
   */
  getMessages(channelId) {
    const targetChannel = channelId || this.activeChannelId;
    return this.chatData.channelMessages[targetChannel] || [];
  }
  /**
   * Get messages since a specific timestamp for a channel
   */
  getMessagesSince(timestamp, channelId) {
    const messages = this.getMessages(channelId);
    const since = new Date(timestamp).getTime();
    return messages.filter((m) => new Date(m.timestamp).getTime() > since);
  }
  /**
   * Get a message by ID from a specific channel
   */
  getMessage(messageId, channelId) {
    const messages = this.getMessages(channelId);
    return messages.find((m) => m.id === messageId);
  }
  /**
   * Toggle a reaction on a message
   */
  async toggleReaction(messageId, emoji, channelId) {
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return false;
    const targetChannel = channelId || this.activeChannelId;
    const messages = this.chatData.channelMessages[targetChannel];
    if (!messages)
      return false;
    const message = messages.find((m) => m.id === messageId);
    if (!message)
      return false;
    if (!message.reactions) {
      message.reactions = [];
    }
    let reaction = message.reactions.find((r) => r.emoji === emoji);
    let wasAdded = false;
    if (reaction) {
      const userIndex = reaction.users.indexOf(currentUser.vaultName);
      if (userIndex !== -1) {
        reaction.users.splice(userIndex, 1);
        if (reaction.users.length === 0) {
          message.reactions = message.reactions.filter((r) => r.emoji !== emoji);
        }
        wasAdded = false;
      } else {
        reaction.users.push(currentUser.vaultName);
        wasAdded = true;
      }
    } else {
      message.reactions.push({
        emoji,
        users: [currentUser.vaultName]
      });
      wasAdded = true;
    }
    this.trackReactionToggle(messageId, emoji, currentUser.vaultName, wasAdded);
    await this.saveChat();
    return true;
  }
  /**
   * Track a reaction toggle for merge protection
   */
  trackReactionToggle(messageId, emoji, username, added) {
    if (!this.recentlyToggledReactions.has(messageId)) {
      this.recentlyToggledReactions.set(messageId, /* @__PURE__ */ new Map());
    }
    const key = `${emoji}|${username}`;
    this.recentlyToggledReactions.get(messageId).set(key, {
      added,
      timestamp: Date.now()
    });
    console.debug(`[Collab-Mentions] Tracked reaction toggle: ${emoji} by ${username} on ${messageId} (${added ? "added" : "removed"})`);
  }
  /**
   * Get recent reaction toggle for a specific emoji+user on a message
   * Returns null if no recent toggle or if it's expired
   */
  getRecentReactionToggle(messageId, emoji, username) {
    const msgToggles = this.recentlyToggledReactions.get(messageId);
    if (!msgToggles)
      return null;
    const key = `${emoji}|${username}`;
    const toggle = msgToggles.get(key);
    if (!toggle)
      return null;
    const age = Date.now() - toggle.timestamp;
    if (age > this.REACTION_TOGGLE_PROTECTION_DURATION) {
      msgToggles.delete(key);
      return null;
    }
    return { added: toggle.added };
  }
  /**
   * Edit a message (only allowed for own messages)
   */
  async editMessage(messageId, newContent, channelId) {
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return false;
    const targetChannel = channelId || this.activeChannelId;
    const messages = this.chatData.channelMessages[targetChannel];
    if (!messages)
      return false;
    const message = messages.find((m) => m.id === messageId);
    if (!message)
      return false;
    if (message.from !== currentUser.vaultName)
      return false;
    if (message.deleted)
      return false;
    message.message = newContent.trim();
    message.edited = true;
    message.editedAt = new Date().toISOString();
    const mentions = _ChatManager.extractMentions(newContent);
    const specialMentions = ["everyone"];
    const validMentions = mentions.filter(
      (m) => specialMentions.includes(m.toLowerCase()) || this.userManager.getUserByName(m) !== void 0
    );
    message.mentions = validMentions.length > 0 ? validMentions : void 0;
    const fileLinks = _ChatManager.extractFileLinks(newContent);
    message.fileLinks = fileLinks.length > 0 ? fileLinks : void 0;
    const channelMentionNames = _ChatManager.extractChannelMentions(newContent);
    const validChannelMentions = [];
    for (const channelName of channelMentionNames) {
      const channel = this.chatData.channels.find(
        (ch) => ch.name.toLowerCase() === channelName.toLowerCase()
      );
      if (channel) {
        validChannelMentions.push(channel.id);
      }
    }
    message.channelMentions = validChannelMentions.length > 0 ? validChannelMentions : void 0;
    await this.saveChat();
    return true;
  }
  /**
   * Delete a message (soft delete - only allowed for own messages or admins)
   */
  async deleteMessage(messageId, channelId) {
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return false;
    const targetChannel = channelId || this.activeChannelId;
    const messages = this.chatData.channelMessages[targetChannel];
    if (!messages)
      return false;
    const message = messages.find((m) => m.id === messageId);
    if (!message)
      return false;
    const isOwner = message.from === currentUser.vaultName;
    const isAdmin = this.userManager.isCurrentUserAdmin();
    if (!isOwner && !isAdmin)
      return false;
    message.deleted = true;
    message.message = "";
    message.images = void 0;
    message.fileLinks = void 0;
    message.mentions = void 0;
    message.channelMentions = void 0;
    await this.saveChat();
    return true;
  }
  /**
   * Check if current user can delete a specific message
   */
  canDeleteMessage(messageId, channelId) {
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return false;
    const targetChannel = channelId || this.activeChannelId;
    const messages = this.chatData.channelMessages[targetChannel];
    if (!messages)
      return false;
    const message = messages.find((m) => m.id === messageId);
    if (!message)
      return false;
    if (message.deleted)
      return false;
    return message.from === currentUser.vaultName || this.userManager.isCurrentUserAdmin();
  }
  // ==================== Read State Management ====================
  /**
   * Mark a channel as read for current user
   */
  async markAsRead(channelId) {
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return;
    const targetChannel = channelId || this.activeChannelId;
    if (!this.chatData.readState[targetChannel]) {
      this.chatData.readState[targetChannel] = {};
    }
    this.chatData.readState[targetChannel][currentUser.vaultName] = new Date().toISOString();
    await this.saveChat();
  }
  /**
   * Get unread count for a specific channel
   */
  getUnreadCount(channelId, username) {
    var _a;
    const messages = this.chatData.channelMessages[channelId] || [];
    const lastRead = (_a = this.chatData.readState[channelId]) == null ? void 0 : _a[username];
    const lastReadTime = lastRead ? new Date(lastRead).getTime() : 0;
    return messages.filter(
      (m) => new Date(m.timestamp).getTime() > lastReadTime && m.from !== username && m.from !== "system" && !m.deleted
    ).length;
  }
  /**
   * Get total unread count across all channels for a user
   */
  getTotalUnreadCount(username) {
    const channels = this.getChannelsForUser(username);
    return channels.reduce((total, channel) => {
      return total + this.getUnreadCount(channel.id, username);
    }, 0);
  }
  /**
   * Check if a channel has been @#mentioned in unread messages (across all channels)
   * Returns true if there are unread messages in any channel that @#mention this channel
   */
  hasUnreadChannelMention(channelId, username) {
    var _a, _b;
    const channels = this.getChannelsForUser(username);
    for (const channel of channels) {
      const lastRead = (_a = this.chatData.readState[channel.id]) == null ? void 0 : _a[username];
      const lastReadTime = lastRead ? new Date(lastRead).getTime() : 0;
      const messages = this.chatData.channelMessages[channel.id] || [];
      for (const msg of messages) {
        const msgTime = new Date(msg.timestamp).getTime();
        if (msgTime <= lastReadTime)
          continue;
        if (msg.from === username)
          continue;
        if (msg.deleted)
          continue;
        if ((_b = msg.channelMentions) == null ? void 0 : _b.includes(channelId)) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Get unread messages that mention the current user (across all channels)
   * Also checks for @everyone and @channel mentions
   */
  getUnreadMentionsForCurrentUser() {
    var _a, _b;
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return [];
    const channels = this.getChannelsForUser(currentUser.vaultName);
    const mentionMessages = [];
    for (const channel of channels) {
      const lastRead = (_a = this.chatData.readState[channel.id]) == null ? void 0 : _a[currentUser.vaultName];
      const lastReadTime = lastRead ? new Date(lastRead).getTime() : 0;
      const messages = this.chatData.channelMessages[channel.id] || [];
      for (const msg of messages) {
        const msgTime = new Date(msg.timestamp).getTime();
        if (msgTime <= lastReadTime)
          continue;
        if (msg.from === currentUser.vaultName)
          continue;
        const isMentioned = (_b = msg.mentions) == null ? void 0 : _b.some((m) => {
          const mentionLower = m.toLowerCase();
          if (mentionLower === currentUser.vaultName.toLowerCase())
            return true;
          if (mentionLower === "everyone")
            return true;
          return false;
        });
        if (isMentioned) {
          mentionMessages.push(msg);
        }
      }
    }
    return mentionMessages;
  }
  /**
   * Get all unread messages for current user (across all channels)
   */
  getUnreadMessagesForCurrentUser() {
    var _a;
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return [];
    const channels = this.getChannelsForUser(currentUser.vaultName);
    const unreadMessages = [];
    for (const channel of channels) {
      const lastRead = (_a = this.chatData.readState[channel.id]) == null ? void 0 : _a[currentUser.vaultName];
      const lastReadTime = lastRead ? new Date(lastRead).getTime() : 0;
      const messages = this.chatData.channelMessages[channel.id] || [];
      for (const msg of messages) {
        const msgTime = new Date(msg.timestamp).getTime();
        if (msgTime > lastReadTime && msg.from !== currentUser.vaultName && !msg.deleted) {
          unreadMessages.push(msg);
        }
      }
    }
    return unreadMessages;
  }
  // ==================== Search ====================
  /**
   * Search messages across all channels or in a specific channel
   * @param query - Search query (case-insensitive)
   * @param channelId - Optional channel ID to search within (null = all channels)
   * @returns Array of messages matching the query with channel info
   */
  searchMessages(query, channelId) {
    if (!query.trim())
      return [];
    const searchLower = query.toLowerCase();
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return [];
    const results = [];
    const channelsToSearch = channelId ? [this.chatData.channels.find((c) => c.id === channelId)].filter(Boolean) : this.getChannelsForUser(currentUser.vaultName);
    for (const channel of channelsToSearch) {
      const messages = this.chatData.channelMessages[channel.id] || [];
      for (const msg of messages) {
        if (msg.deleted)
          continue;
        if (msg.message.toLowerCase().includes(searchLower)) {
          results.push({
            ...msg,
            channelId: channel.id,
            channelName: channel.name
          });
          continue;
        }
        if (msg.from.toLowerCase().includes(searchLower)) {
          results.push({
            ...msg,
            channelId: channel.id,
            channelName: channel.name
          });
        }
      }
    }
    results.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
    return results;
  }
  // ==================== Utility ====================
  /**
   * Get the chat file path for watching
   */
  getChatFilePath() {
    return CHAT_FILE;
  }
  /**
   * Extract file links from message text (format: [[filename]])
   */
  static extractFileLinks(message) {
    const regex = /\[\[([^\]]+)\]\]/g;
    const links = [];
    let match;
    while ((match = regex.exec(message)) !== null) {
      links.push(match[1]);
    }
    return links;
  }
  /**
   * Extract @mentions from message text (excludes channel mentions)
   */
  static extractMentions(message) {
    const regex = /@(?!#)(\w+)/g;
    const mentions = [];
    let match;
    while ((match = regex.exec(message)) !== null) {
      mentions.push(match[1]);
    }
    return mentions;
  }
  /**
   * Extract @#channel mentions from message text
   */
  static extractChannelMentions(message) {
    const regex = /@#([\w-]+)/g;
    const mentions = [];
    let match;
    while ((match = regex.exec(message)) !== null) {
      mentions.push(match[1]);
    }
    return mentions;
  }
  /**
   * Extract URLs from message text
   */
  static extractUrls(message) {
    const regex = /(https?:\/\/[^\s<>[\]]+)/g;
    const urls = [];
    let match;
    while ((match = regex.exec(message)) !== null) {
      urls.push(match[1]);
    }
    return urls;
  }
  /**
   * Check if message contains media (images)
   */
  static hasMedia(message) {
    return !!(message.images && message.images.length > 0);
  }
};
var ChatManager = _ChatManager;
/**
 * Common emoji reactions for quick access
 */
ChatManager.QUICK_REACTIONS = ["\u{1F44D}", "\u2764\uFE0F", "\u{1F602}", "\u{1F62E}", "\u{1F622}", "\u{1F389}"];

// src/reminderManager.ts
var REMINDERS_FILE = ".collab-mentions/reminders.json";
var ReminderManager = class {
  constructor(app, userManager) {
    this.checkInterval = null;
    this.onReminderDue = null;
    this.app = app;
    this.userManager = userManager;
    this.remindersData = { reminders: [] };
  }
  /**
   * Set callback for when a reminder is due
   */
  setOnReminderDue(callback) {
    this.onReminderDue = callback;
  }
  /**
   * Generate a simple unique ID
   */
  generateId() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2, 11);
  }
  /**
   * Load reminders from vault
   */
  async loadReminders() {
    try {
      if (!await this.app.vault.adapter.exists(".collab-mentions")) {
        await this.app.vault.adapter.mkdir(".collab-mentions");
      }
      if (await this.app.vault.adapter.exists(REMINDERS_FILE)) {
        const content = await this.app.vault.adapter.read(REMINDERS_FILE);
        this.remindersData = JSON.parse(content);
      } else {
        this.remindersData = { reminders: [] };
      }
    } catch (error) {
      console.error("Error loading reminders:", error);
      this.remindersData = { reminders: [] };
    }
  }
  /**
   * Save reminders to vault
   */
  async saveReminders() {
    try {
      const content = JSON.stringify(this.remindersData, null, 2);
      await this.app.vault.adapter.write(REMINDERS_FILE, content);
    } catch (error) {
      console.error("Error saving reminders:", error);
    }
  }
  /**
   * Create a new reminder
   */
  async createReminder(message, dueDate, priority = "normal", linkedFile, isGlobal = false) {
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return null;
    const reminder = {
      id: this.generateId(),
      user: currentUser.vaultName,
      message,
      dueDate: dueDate.toISOString(),
      createdAt: new Date().toISOString(),
      completed: false,
      notified: false,
      notifiedUsers: [],
      priority,
      linkedFile,
      isGlobal
    };
    this.remindersData.reminders.push(reminder);
    await this.saveReminders();
    return reminder;
  }
  /**
   * Get all reminders (for tracking purposes)
   */
  getReminders() {
    return this.remindersData.reminders;
  }
  /**
   * Get all reminders visible to the current user (own + global)
   */
  getRemindersForCurrentUser() {
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return [];
    return this.remindersData.reminders.filter((r) => r.user === currentUser.vaultName || r.isGlobal).sort((a, b) => new Date(a.dueDate).getTime() - new Date(b.dueDate).getTime());
  }
  /**
   * Get upcoming reminders (not completed, not past due)
   */
  getUpcomingReminders() {
    const now = new Date();
    return this.getRemindersForCurrentUser().filter((r) => !r.completed && new Date(r.dueDate) > now);
  }
  /**
   * Get past due reminders (not completed, past due date)
   */
  getPastDueReminders() {
    const now = new Date();
    return this.getRemindersForCurrentUser().filter((r) => !r.completed && new Date(r.dueDate) <= now);
  }
  /**
   * Get completed reminders
   */
  getCompletedReminders() {
    return this.getRemindersForCurrentUser().filter((r) => r.completed).sort((a, b) => new Date(b.completedAt || b.dueDate).getTime() - new Date(a.completedAt || a.dueDate).getTime());
  }
  /**
   * Mark a reminder as completed
   */
  async completeReminder(reminderId) {
    const reminder = this.remindersData.reminders.find((r) => r.id === reminderId);
    if (reminder) {
      reminder.completed = true;
      reminder.completedAt = new Date().toISOString();
      await this.saveReminders();
    }
  }
  /**
   * Delete a reminder
   */
  async deleteReminder(reminderId) {
    this.remindersData.reminders = this.remindersData.reminders.filter((r) => r.id !== reminderId);
    await this.saveReminders();
  }
  /**
   * Edit a reminder
   */
  async editReminder(reminderId, updates) {
    const reminder = this.remindersData.reminders.find((r) => r.id === reminderId);
    if (reminder) {
      if (updates.message !== void 0)
        reminder.message = updates.message;
      if (updates.dueDate !== void 0)
        reminder.dueDate = updates.dueDate;
      if (updates.priority !== void 0)
        reminder.priority = updates.priority;
      if (updates.dueDate !== void 0) {
        reminder.notified = false;
        reminder.notifiedUsers = [];
      }
      await this.saveReminders();
    }
  }
  /**
   * Snooze a reminder by a certain amount of time
   */
  async snoozeReminder(reminderId, minutes) {
    const reminder = this.remindersData.reminders.find((r) => r.id === reminderId);
    if (reminder) {
      const newDueDate = new Date(Date.now() + minutes * 60 * 1e3);
      reminder.dueDate = newDueDate.toISOString();
      reminder.notified = false;
      reminder.notifiedUsers = [];
      await this.saveReminders();
    }
  }
  /**
   * Check for due reminders and trigger notifications
   */
  async checkDueReminders() {
    const now = new Date();
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser) {
      console.debug("[Collab-Mentions] checkDueReminders: no current user");
      return [];
    }
    const dueReminders = [];
    let needsSave = false;
    const activeReminders = this.remindersData.reminders.filter((r) => !r.completed);
    if (activeReminders.length > 0) {
      console.debug("[Collab-Mentions] checkDueReminders: checking", activeReminders.length, "active reminders at", now.toISOString());
    }
    for (const reminder of this.remindersData.reminders) {
      if (reminder.completed)
        continue;
      const dueDate = new Date(reminder.dueDate);
      const isDue = dueDate <= now;
      const isOwner = reminder.user === currentUser.vaultName;
      const alreadyNotified = reminder.notified;
      if (isDue) {
        console.debug("[Collab-Mentions] Reminder due check:", {
          id: reminder.id,
          message: reminder.message.substring(0, 30),
          dueDate: dueDate.toISOString(),
          now: now.toISOString(),
          isDue,
          isOwner,
          alreadyNotified,
          isGlobal: reminder.isGlobal
        });
      }
      if (dueDate > now)
        continue;
      let shouldNotify = false;
      if (reminder.isGlobal) {
        const notifiedUsers = reminder.notifiedUsers || [];
        if (!notifiedUsers.includes(currentUser.vaultName)) {
          shouldNotify = true;
          if (!reminder.notifiedUsers)
            reminder.notifiedUsers = [];
          reminder.notifiedUsers.push(currentUser.vaultName);
          needsSave = true;
          console.debug("[Collab-Mentions] Global reminder needs notification for user:", currentUser.vaultName);
        }
      } else {
        if (reminder.user === currentUser.vaultName && !reminder.notified) {
          shouldNotify = true;
          reminder.notified = true;
          needsSave = true;
          console.debug("[Collab-Mentions] Personal reminder needs notification");
        }
      }
      if (shouldNotify) {
        dueReminders.push(reminder);
        if (this.onReminderDue) {
          console.debug("[Collab-Mentions] Triggering onReminderDue callback for:", reminder.message.substring(0, 30));
          this.onReminderDue(reminder);
        } else {
          console.error("[Collab-Mentions] WARNING: onReminderDue callback not set!");
        }
      }
    }
    if (needsSave) {
      this.remindersData.lastChecked = now.toISOString();
      await this.saveReminders();
      console.debug("[Collab-Mentions] Saved reminders after marking as notified");
    }
    return dueReminders;
  }
  /**
   * Start periodic checking for due reminders
   */
  startPeriodicCheck(intervalMs = 6e4) {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
    }
    console.debug("[Collab-Mentions] Starting periodic reminder check every", intervalMs, "ms");
    console.debug("[Collab-Mentions] Running immediate check on startPeriodicCheck");
    void this.checkDueReminders();
    this.checkInterval = window.setInterval(() => {
      void (async () => {
        const now = new Date();
        const activeReminders = this.remindersData.reminders.filter((r) => !r.completed && !r.notified);
        if (activeReminders.length > 0) {
          console.debug(
            "[Collab-Mentions] Periodic check running at",
            now.toISOString(),
            "with",
            activeReminders.length,
            "active unnotified reminders"
          );
        }
        await this.loadReminders();
        const dueReminders = await this.checkDueReminders();
        if (dueReminders.length > 0) {
          console.debug("[Collab-Mentions] Periodic check found due reminders:", dueReminders.length);
        }
      })();
    }, intervalMs);
  }
  /**
   * Stop periodic checking
   */
  stopPeriodicCheck() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
      this.checkInterval = null;
    }
  }
  /**
   * Get the reminders file path for file watching
   */
  getRemindersFilePath() {
    return REMINDERS_FILE;
  }
  /**
   * Parse natural language date/time string
   * Supports: "tomorrow", "in 2 hours", "next monday", "jan 15 3pm", etc.
   */
  static parseNaturalDate(input) {
    const now = new Date();
    const lowered = input.toLowerCase().trim();
    if (lowered === "now" || lowered === "immediately") {
      return now;
    }
    const inMatch = lowered.match(/^in\s+(\d+)\s*(min(?:ute)?s?|hours?|days?|weeks?|months?)$/);
    if (inMatch) {
      const amount = parseInt(inMatch[1]);
      const unit = inMatch[2];
      const result = new Date(now);
      if (unit.startsWith("min")) {
        result.setMinutes(result.getMinutes() + amount);
      } else if (unit.startsWith("hour")) {
        result.setHours(result.getHours() + amount);
      } else if (unit.startsWith("day")) {
        result.setDate(result.getDate() + amount);
      } else if (unit.startsWith("week")) {
        result.setDate(result.getDate() + amount * 7);
      } else if (unit.startsWith("month")) {
        result.setMonth(result.getMonth() + amount);
      }
      return result;
    }
    if (lowered.startsWith("tomorrow")) {
      const result = new Date(now);
      result.setDate(result.getDate() + 1);
      const timeMatch = lowered.match(/(\d{1,2})(?::(\d{2}))?\s*(am|pm)?/);
      if (timeMatch) {
        let hours = parseInt(timeMatch[1]);
        const minutes = timeMatch[2] ? parseInt(timeMatch[2]) : 0;
        const ampm = timeMatch[3];
        if (ampm === "pm" && hours < 12)
          hours += 12;
        if (ampm === "am" && hours === 12)
          hours = 0;
        result.setHours(hours, minutes, 0, 0);
      } else {
        result.setHours(9, 0, 0, 0);
      }
      return result;
    }
    if (lowered.startsWith("today")) {
      const result = new Date(now);
      const timeMatch = lowered.match(/(\d{1,2})(?::(\d{2}))?\s*(am|pm)?/);
      if (timeMatch) {
        let hours = parseInt(timeMatch[1]);
        const minutes = timeMatch[2] ? parseInt(timeMatch[2]) : 0;
        const ampm = timeMatch[3];
        if (ampm === "pm" && hours < 12)
          hours += 12;
        if (ampm === "am" && hours === 12)
          hours = 0;
        result.setHours(hours, minutes, 0, 0);
      }
      return result;
    }
    const dayNames = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
    const nextDayMatch = lowered.match(/^next\s+(sunday|monday|tuesday|wednesday|thursday|friday|saturday)(?:\s+(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)?)?$/);
    if (nextDayMatch) {
      const targetDay = dayNames.indexOf(nextDayMatch[1]);
      const result = new Date(now);
      const currentDay = result.getDay();
      let daysToAdd = targetDay - currentDay;
      if (daysToAdd <= 0)
        daysToAdd += 7;
      result.setDate(result.getDate() + daysToAdd);
      if (nextDayMatch[2]) {
        let hours = parseInt(nextDayMatch[2]);
        const minutes = nextDayMatch[3] ? parseInt(nextDayMatch[3]) : 0;
        const ampm = nextDayMatch[4];
        if (ampm === "pm" && hours < 12)
          hours += 12;
        if (ampm === "am" && hours === 12)
          hours = 0;
        result.setHours(hours, minutes, 0, 0);
      } else {
        result.setHours(9, 0, 0, 0);
      }
      return result;
    }
    const thisDayMatch = lowered.match(/^this\s+(sunday|monday|tuesday|wednesday|thursday|friday|saturday)(?:\s+(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)?)?$/);
    if (thisDayMatch) {
      const targetDay = dayNames.indexOf(thisDayMatch[1]);
      const result = new Date(now);
      const currentDay = result.getDay();
      let daysToAdd = targetDay - currentDay;
      if (daysToAdd < 0)
        daysToAdd += 7;
      result.setDate(result.getDate() + daysToAdd);
      if (thisDayMatch[2]) {
        let hours = parseInt(thisDayMatch[2]);
        const minutes = thisDayMatch[3] ? parseInt(thisDayMatch[3]) : 0;
        const ampm = thisDayMatch[4];
        if (ampm === "pm" && hours < 12)
          hours += 12;
        if (ampm === "am" && hours === 12)
          hours = 0;
        result.setHours(hours, minutes, 0, 0);
      } else {
        result.setHours(9, 0, 0, 0);
      }
      return result;
    }
    const monthNames = ["jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec"];
    const monthMatch = lowered.match(/^(jan(?:uary)?|feb(?:ruary)?|mar(?:ch)?|apr(?:il)?|may|jun(?:e)?|jul(?:y)?|aug(?:ust)?|sep(?:tember)?|oct(?:ober)?|nov(?:ember)?|dec(?:ember)?)\s+(\d{1,2})(?:(?:st|nd|rd|th))?(?:\s+(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)?)?$/);
    if (monthMatch) {
      const monthStr = monthMatch[1].substring(0, 3);
      const month = monthNames.indexOf(monthStr);
      const day = parseInt(monthMatch[2]);
      const result = new Date(now.getFullYear(), month, day);
      if (result < now) {
        result.setFullYear(result.getFullYear() + 1);
      }
      if (monthMatch[3]) {
        let hours = parseInt(monthMatch[3]);
        const minutes = monthMatch[4] ? parseInt(monthMatch[4]) : 0;
        const ampm = monthMatch[5];
        if (ampm === "pm" && hours < 12)
          hours += 12;
        if (ampm === "am" && hours === 12)
          hours = 0;
        result.setHours(hours, minutes, 0, 0);
      } else {
        result.setHours(9, 0, 0, 0);
      }
      return result;
    }
    const timeOnlyMatch = lowered.match(/^(\d{1,2})(?::(\d{2}))?\s*(am|pm)?$/);
    if (timeOnlyMatch) {
      const result = new Date(now);
      let hours = parseInt(timeOnlyMatch[1]);
      const minutes = timeOnlyMatch[2] ? parseInt(timeOnlyMatch[2]) : 0;
      const ampm = timeOnlyMatch[3];
      if (ampm === "pm" && hours < 12)
        hours += 12;
      if (ampm === "am" && hours === 12)
        hours = 0;
      result.setHours(hours, minutes, 0, 0);
      if (result <= now) {
        result.setDate(result.getDate() + 1);
      }
      return result;
    }
    const parsed = Date.parse(input);
    if (!isNaN(parsed)) {
      return new Date(parsed);
    }
    return null;
  }
  /**
   * Format a date for display
   */
  static formatDueDate(dueDate) {
    const date = new Date(dueDate);
    const now = new Date();
    const diff = date.getTime() - now.getTime();
    const minutes = Math.floor(diff / 6e4);
    const hours = Math.floor(diff / 36e5);
    const days = Math.floor(diff / 864e5);
    if (diff < 0) {
      const absDays = Math.abs(days);
      const absHours = Math.abs(hours);
      const absMinutes = Math.abs(minutes);
      if (absDays > 0) {
        return `${absDays} day${absDays > 1 ? "s" : ""} overdue`;
      } else if (absHours > 0) {
        return `${absHours} hour${absHours > 1 ? "s" : ""} overdue`;
      } else {
        return `${absMinutes} min overdue`;
      }
    }
    if (days === 0) {
      if (hours === 0) {
        return `in ${minutes} min`;
      }
      return `in ${hours} hour${hours > 1 ? "s" : ""}`;
    } else if (days === 1) {
      return `tomorrow at ${date.toLocaleTimeString([], { hour: "numeric", minute: "2-digit" })}`;
    } else if (days < 7) {
      return `${date.toLocaleDateString([], { weekday: "long" })} at ${date.toLocaleTimeString([], { hour: "numeric", minute: "2-digit" })}`;
    } else {
      return date.toLocaleDateString([], { month: "short", day: "numeric", hour: "numeric", minute: "2-digit" });
    }
  }
  /**
   * Get suggestion for natural language input
   */
  static getSuggestions() {
    return [
      "in 30 minutes",
      "in 1 hour",
      "in 2 hours",
      "tomorrow",
      "tomorrow 9am",
      "tomorrow 2pm",
      "next monday",
      "next friday 3pm",
      "in 3 days",
      "in 1 week"
    ];
  }
};

// src/notifier.ts
var import_obsidian2 = require("obsidian");
var Notifier = class {
  constructor(app, mentionParser, userManager) {
    this.notificationSound = null;
    this.app = app;
    this.mentionParser = mentionParser;
    this.userManager = userManager;
    this.initSound();
  }
  /**
   * Initialize notification sound
   */
  initSound() {
    try {
      this.notificationSound = new Audio(
        "data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdH2Mi4eBdWxzgImLhXlta3WBi42HfHJud4SLjIV5bmt2goyMhXlsandCjIyFeWxqdYKMjIV5bGp1goyMhXlsanWCjIyFeWxqdYKMjIV5bA=="
      );
    } catch (e) {
      console.debug("Could not initialize notification sound");
    }
  }
  /**
   * Play notification sound
   */
  playSound() {
    if (this.notificationSound) {
      this.notificationSound.currentTime = 0;
      this.notificationSound.play().catch(() => {
      });
    }
  }
  /**
   * Show a simple notice
   */
  showNotice(message, duration = 5e3) {
    console.debug("[Collab-Mentions] Showing notice:", message);
    try {
      new import_obsidian2.Notice(message, duration);
      console.debug("[Collab-Mentions] Notice created successfully");
    } catch (e) {
      console.error("[Collab-Mentions] Error creating notice:", e);
    }
  }
  /**
   * Check for unread mentions and notify
   */
  async checkAndNotify(playSound = true) {
    await Promise.resolve();
    const unread = this.mentionParser.getUnreadMentions();
    if (unread.length > 0) {
      if (playSound) {
        this.playSound();
      }
      if (unread.length === 1) {
        const mention = unread[0];
        this.showNotice(
          `\u{1F4EC} New mention from @${mention.from}:
"${this.truncate(mention.context, 50)}"`,
          8e3
        );
      } else {
        this.showNotice(
          `\u{1F4EC} You have ${unread.length} unread mentions!`,
          8e3
        );
      }
    }
    return unread.length;
  }
  /**
   * Notify about specific new unread mentions (prevents repeat notifications)
   */
  async notifyNewUnread(mentions, playSound = true) {
    await Promise.resolve();
    if (mentions.length === 0)
      return;
    if (playSound) {
      this.playSound();
    }
    if (mentions.length === 1) {
      const mention = mentions[0];
      this.showNotice(
        `\u{1F4EC} New mention from @${mention.from}:
"${this.truncate(mention.context, 50)}"`,
        8e3
      );
    } else {
      this.showNotice(
        `\u{1F4EC} ${mentions.length} new mentions!`,
        8e3
      );
    }
  }
  /**
   * Show startup notification modal with all unread mentions
   */
  showStartupNotifications(unreadMentions) {
    if (unreadMentions.length === 0)
      return;
    const modal = new UnreadMentionsModal(
      this.app,
      unreadMentions,
      this.mentionParser
    );
    modal.open();
  }
  /**
   * Notify about a new mention that was just created
   */
  notifyNewMention(mention) {
    this.showNotice(
      `\u{1F4E4} Mentioned @${mention.to} in ${this.getFileName(mention.file)}`,
      3e3
    );
  }
  /**
   * Truncate text to a maximum length
   */
  truncate(text, maxLength) {
    if (text.length <= maxLength)
      return text;
    return text.substring(0, maxLength - 3) + "...";
  }
  /**
   * Get just the filename from a path
   */
  getFileName(path) {
    return path.split("/").pop() || path;
  }
};
var UnreadMentionsModal = class extends import_obsidian2.Modal {
  constructor(app, mentions, mentionParser) {
    super(app);
    this.mentions = mentions;
    this.mentionParser = mentionParser;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("collab-mentions-modal");
    contentEl.createEl("h2", { text: `\u{1F4EC} You have ${this.mentions.length} unread mention${this.mentions.length > 1 ? "s" : ""}` });
    const listEl = contentEl.createEl("div", { cls: "mention-list" });
    for (const mention of this.mentions) {
      const itemEl = listEl.createEl("div", { cls: "mention-item" });
      const headerEl = itemEl.createEl("div", { cls: "mention-header" });
      headerEl.createEl("span", {
        text: `From @${mention.from}`,
        cls: "mention-from"
      });
      headerEl.createEl("span", {
        text: this.formatDate(mention.timestamp),
        cls: "mention-date"
      });
      itemEl.createEl("div", {
        text: mention.context,
        cls: "mention-context"
      });
      const fileEl = itemEl.createEl("div", { cls: "mention-file" });
      const link = fileEl.createEl("a", {
        text: `\u{1F4C4} ${mention.file}`,
        cls: "mention-file-link"
      });
      link.addEventListener("click", (e) => {
        e.preventDefault();
        this.close();
        const file = this.app.vault.getAbstractFileByPath(mention.file);
        if (file instanceof import_obsidian2.TFile) {
          void (async () => {
            const leaf = this.app.workspace.getLeaf();
            await leaf.openFile(file);
            const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
            if (view && view.editor) {
              view.editor.setCursor({ line: mention.line, ch: 0 });
              view.editor.scrollIntoView({
                from: { line: mention.line, ch: 0 },
                to: { line: mention.line, ch: 0 }
              }, true);
            }
          })();
        }
      });
      const actionsEl = itemEl.createEl("div", { cls: "mention-actions" });
      const markReadBtn = actionsEl.createEl("button", {
        text: "Mark read \u2713",
        cls: "mention-btn"
      });
      markReadBtn.addEventListener("click", () => {
        void (async () => {
          await this.mentionParser.markAsRead(mention.id);
          itemEl.addClass("mention-read");
          markReadBtn.disabled = true;
          markReadBtn.textContent = "Read \u2713";
        })();
      });
    }
    const footerEl = contentEl.createEl("div", { cls: "mention-footer" });
    const markAllBtn = footerEl.createEl("button", {
      text: "Mark all as read",
      cls: "mention-btn-primary"
    });
    markAllBtn.addEventListener("click", () => {
      void (async () => {
        await this.mentionParser.markAllAsRead();
        this.close();
        new import_obsidian2.Notice("All mentions marked as read.");
      })();
    });
    const closeBtn = footerEl.createEl("button", {
      text: "Close",
      cls: "mention-btn"
    });
    closeBtn.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  formatDate(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    const minutes = Math.floor(diff / 6e4);
    const hours = Math.floor(diff / 36e5);
    const days = Math.floor(diff / 864e5);
    if (minutes < 60) {
      return `${minutes}m ago`;
    } else if (hours < 24) {
      return `${hours}h ago`;
    } else if (days < 7) {
      return `${days}d ago`;
    } else {
      return date.toLocaleDateString();
    }
  }
};

// src/ui/registerModal.ts
var import_obsidian3 = require("obsidian");
var ConfirmModal = class extends import_obsidian3.Modal {
  constructor(app, title, message, onConfirm) {
    super(app);
    this.title = title;
    this.message = message;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("collab-confirm-modal");
    new import_obsidian3.Setting(contentEl).setName(this.title).setHeading();
    contentEl.createEl("p", { text: this.message });
    const buttonRow = contentEl.createEl("div", { cls: "collab-confirm-buttons" });
    const cancelBtn = buttonRow.createEl("button", {
      text: "Cancel",
      cls: "collab-confirm-cancel-btn"
    });
    cancelBtn.addEventListener("click", () => this.close());
    const confirmBtn = buttonRow.createEl("button", {
      text: "Confirm",
      cls: "collab-confirm-action-btn"
    });
    confirmBtn.addEventListener("click", () => {
      this.close();
      this.onConfirm();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var RegisterModal = class extends import_obsidian3.Modal {
  constructor(app, userManager, onRegister) {
    super(app);
    this.userManager = userManager;
    this.onRegister = onRegister;
  }
  onOpen() {
    const { contentEl } = this;
    new import_obsidian3.Setting(contentEl).setName("Register for collab mentions \u{1F464}").setHeading();
    const localId = this.userManager.getLocalIdentifier();
    const os2 = this.userManager.getOS();
    contentEl.createEl("p", {
      text: "Register your identity to use @mentions in this shared vault.",
      cls: "setting-item-description"
    });
    contentEl.createEl("div", {
      text: `Your machine: ${localId} (${os2})`,
      cls: "collab-machine-info"
    });
    let vaultName = "";
    new import_obsidian3.Setting(contentEl).setName("Your display name").setDesc("This is how others will mention you. For example, type your display name as shown in the expandable window.").addText(
      (text) => text.setPlaceholder("Enter your name").onChange((value) => {
        vaultName = value.trim();
      })
    );
    const existingUsers = this.userManager.getAllUsers();
    if (existingUsers.length > 0) {
      new import_obsidian3.Setting(contentEl).setName("Existing team members").setHeading();
      const userList = contentEl.createEl("ul", { cls: "collab-user-list" });
      for (const user of existingUsers) {
        const li = userList.createEl("li");
        li.createEl("span", {
          text: `@${user.vaultName}`,
          cls: "collab-username"
        });
        li.createEl("span", {
          text: ` (${user.os})`,
          cls: "collab-user-os"
        });
      }
    }
    new import_obsidian3.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Register").setCta().onClick(async () => {
        if (!vaultName) {
          new import_obsidian3.Notice("Please enter a display name");
          return;
        }
        if (vaultName.includes(" ")) {
          new import_obsidian3.Notice("Display name cannot contain spaces");
          return;
        }
        if (!/^[a-zA-Z0-9_]+$/.test(vaultName)) {
          new import_obsidian3.Notice("Display name can only contain letters, numbers, and underscores");
          return;
        }
        const success = await this.userManager.registerUser(vaultName);
        if (success) {
          this.onRegister();
          this.close();
        }
      })
    ).addButton(
      (btn) => btn.setButtonText("Cancel").onClick(() => {
        this.close();
      })
    );
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var UserManagementModal = class extends import_obsidian3.Modal {
  constructor(app, userManager, onUpdate) {
    super(app);
    this.userManager = userManager;
    this.onUpdate = onUpdate;
  }
  onOpen() {
    this.render();
  }
  render() {
    const { contentEl } = this;
    contentEl.empty();
    new import_obsidian3.Setting(contentEl).setName("Team members \u{1F465}").setHeading();
    const currentUser = this.userManager.getCurrentUser();
    const allUsers = this.userManager.getAllUsers();
    const isAdmin = this.userManager.isCurrentUserAdmin();
    if (currentUser) {
      const userInfo2 = contentEl.createEl("p", { cls: "collab-current-user" });
      userInfo2.createEl("span", { text: `You are registered as: @${currentUser.vaultName}` });
      if (isAdmin) {
        userInfo2.createEl("span", { text: " \u2014 admin", cls: "collab-admin-badge" });
      }
    }
    new import_obsidian3.Setting(contentEl).setName("Registered team members").setHeading();
    if (allUsers.length === 0) {
      contentEl.createEl("p", {
        text: "No users registered yet.",
        cls: "setting-item-description"
      });
    } else {
      const tableWrapper = contentEl.createEl("div", { cls: "collab-users-table-wrapper" });
      const table = tableWrapper.createEl("table", { cls: "collab-users-table" });
      const headerRow = table.createEl("tr");
      headerRow.createEl("th", { text: "Name" });
      headerRow.createEl("th", { text: "Role" });
      headerRow.createEl("th", { text: "Machine" });
      headerRow.createEl("th", { text: "OS" });
      headerRow.createEl("th", { text: "Registered" });
      if (isAdmin) {
        headerRow.createEl("th", { text: "Actions" });
      }
      for (const user of allUsers) {
        const row = table.createEl("tr");
        const nameCell = row.createEl("td");
        nameCell.createEl("span", {
          text: `@${user.vaultName}`,
          cls: "collab-username"
        });
        if (currentUser && user.localIdentifier === currentUser.localIdentifier) {
          nameCell.createEl("span", {
            text: " (you)",
            cls: "collab-you-tag"
          });
        }
        const roleCell = row.createEl("td");
        if (user.isAdmin) {
          const adminText = user.adminLevel === "primary" ? "Primary admin" : "Secondary admin";
          roleCell.createEl("span", {
            text: adminText,
            cls: user.adminLevel === "primary" ? "collab-admin-badge collab-primary-admin" : "collab-admin-badge"
          });
        } else {
          roleCell.createEl("span", { text: "Member", cls: "collab-member-badge" });
        }
        if (user.registrationNumber) {
          roleCell.createEl("span", {
            text: ` #${user.registrationNumber}`,
            cls: "collab-registration-number"
          });
        }
        row.createEl("td", { text: user.localIdentifier.split("@")[1] || user.localIdentifier });
        row.createEl("td", { text: user.os });
        row.createEl("td", { text: new Date(user.registered).toLocaleDateString() });
        const isPrimaryAdmin = this.userManager.isCurrentUserPrimaryAdmin();
        if (isAdmin) {
          const actionsCell = row.createEl("td", { cls: "collab-actions-cell" });
          const isCurrentUserRow = currentUser && user.localIdentifier === currentUser.localIdentifier;
          const isTargetPrimaryAdmin = user.adminLevel === "primary";
          if (isPrimaryAdmin && !isTargetPrimaryAdmin && !isCurrentUserRow) {
            const adminBtn = actionsCell.createEl("button", {
              text: user.isAdmin ? "Demote" : "Promote",
              cls: "collab-action-btn"
            });
            adminBtn.addEventListener("click", () => {
              void (async () => {
                if (user.isAdmin) {
                  await this.userManager.demoteFromAdmin(user.vaultName);
                } else {
                  await this.userManager.promoteToAdmin(user.vaultName);
                }
                this.render();
                this.onUpdate();
              })();
            });
          }
          if (!isCurrentUserRow && !isTargetPrimaryAdmin) {
            const removeBtn = actionsCell.createEl("button", {
              text: "Remove",
              cls: "collab-action-btn collab-action-btn-danger"
            });
            removeBtn.addEventListener("click", () => {
              new ConfirmModal(
                this.app,
                "Remove team member?",
                `Are you sure you want to remove "${user.vaultName}" from the team?`,
                () => {
                  void (async () => {
                    await this.userManager.removeUser(user.vaultName);
                    this.render();
                    this.onUpdate();
                  })();
                }
              ).open();
            });
          }
        }
      }
    }
    const footerEl = contentEl.createEl("div", { cls: "collab-modal-footer" });
    if (currentUser) {
      new import_obsidian3.Setting(footerEl).addButton(
        (btn) => btn.setButtonText("Unregister me").setWarning().onClick(() => {
          new ConfirmModal(
            this.app,
            "Unregister from machine?",
            `Are you sure you want to unregister "${currentUser.vaultName}" from this machine?`,
            () => {
              void (async () => {
                await this.userManager.unregisterCurrentUser();
                this.onUpdate();
                this.close();
              })();
            }
          ).open();
        })
      ).addButton(
        (btn) => btn.setButtonText("Close").onClick(() => this.close())
      );
    } else {
      new import_obsidian3.Setting(footerEl).addButton(
        (btn) => btn.setButtonText("Register").setCta().onClick(() => {
          this.close();
          new RegisterModal(this.app, this.userManager, this.onUpdate).open();
        })
      ).addButton(
        (btn) => btn.setButtonText("Close").onClick(() => this.close())
      );
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/mentionPanel.ts
var import_obsidian4 = require("obsidian");
var MENTION_PANEL_VIEW_TYPE = "collab-mentions-panel";
var MentionPanelView = class extends import_obsidian4.ItemView {
  // Search results
  constructor(leaf, mentionParser, userManager, chatManager, reminderManager, onBadgeUpdate) {
    super(leaf);
    // Callback to update ribbon badge
    this.chatContainer = null;
    this.pendingImages = [];
    // Images to attach to next message
    this.activeTab = "inbox";
    // Track active tab
    this.channelListCollapsed = false;
    // Track channel list collapsed state
    this.isRefreshing = false;
    // Prevent re-renders while refreshing
    this.messagesContainer = null;
    // Reference for smart updates
    this.messagesWrapper = null;
    // Reference for messages wrapper (includes jump button)
    this.lastInputValue = "";
    // Preserve input during refresh
    this.replyingTo = null;
    // Message being replied to
    this.inboxFilter = "all";
    // Inbox filter state
    this.chatSearchQuery = "";
    // Current search query for chat
    this.chatSearchResults = [];
    this.inputAreaContainer = null;
    // Reference for updating input area
    this.imagePreviewContainer = null;
    // Reference for image preview
    this.typingIndicatorEl = null;
    // Reference for typing indicator
    this.typingTimeout = null;
    this.mentionParser = mentionParser;
    this.userManager = userManager;
    this.chatManager = chatManager;
    this.reminderManager = reminderManager;
    this.onBadgeUpdate = onBadgeUpdate;
  }
  getViewType() {
    return MENTION_PANEL_VIEW_TYPE;
  }
  getDisplayText() {
    return "Mentions";
  }
  getIcon() {
    return "at-sign";
  }
  async onOpen() {
    await this.render();
  }
  /**
   * Public method to switch to a specific tab
   */
  switchToTab(tab) {
    this.activeTab = tab;
    void this.render();
  }
  /**
   * Public method to switch to a specific channel (also switches to chat tab)
   */
  switchToChannel(channelId) {
    this.chatManager.setActiveChannel(channelId);
    this.activeTab = "chat";
    void this.render();
  }
  async render() {
    await Promise.resolve();
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("collab-mentions-panel");
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser) {
      container.createEl("div", {
        text: "Please register to use mentions.",
        cls: "collab-panel-notice"
      });
      return;
    }
    const headerEl = container.createEl("div", { cls: "collab-panel-header" });
    headerEl.createEl("h4", { text: `@${currentUser.vaultName}` });
    const tabsEl = container.createEl("div", { cls: "collab-tabs" });
    const inboxTab = tabsEl.createEl("button", {
      text: "Inbox",
      cls: "collab-tab active"
    });
    const sentTab = tabsEl.createEl("button", {
      text: "Sent",
      cls: "collab-tab"
    });
    const teamTab = tabsEl.createEl("button", {
      text: "Team",
      cls: "collab-tab"
    });
    const chatTab = tabsEl.createEl("button", {
      text: "Chat",
      cls: "collab-tab"
    });
    const remindersTab = tabsEl.createEl("button", {
      text: "Reminders",
      cls: "collab-tab"
    });
    const contentEl = container.createEl("div", { cls: "collab-panel-content" });
    const setActiveTab = (active, tabName) => {
      inboxTab.removeClass("active");
      sentTab.removeClass("active");
      teamTab.removeClass("active");
      chatTab.removeClass("active");
      remindersTab.removeClass("active");
      active.addClass("active");
      this.activeTab = tabName;
    };
    inboxTab.addEventListener("click", () => {
      setActiveTab(inboxTab, "inbox");
      void this.renderInbox(contentEl);
    });
    sentTab.addEventListener("click", () => {
      setActiveTab(sentTab, "sent");
      void this.renderSent(contentEl);
    });
    teamTab.addEventListener("click", () => {
      setActiveTab(teamTab, "team");
      void (async () => {
        await this.renderTeam(contentEl);
      })();
    });
    chatTab.addEventListener("click", () => {
      setActiveTab(chatTab, "chat");
      void (async () => {
        await this.renderChat(contentEl);
      })();
    });
    remindersTab.addEventListener("click", () => {
      setActiveTab(remindersTab, "reminders");
      void (async () => {
        await this.renderReminders(contentEl);
      })();
    });
    switch (this.activeTab) {
      case "sent":
        setActiveTab(sentTab, "sent");
        void this.renderSent(contentEl);
        break;
      case "team":
        setActiveTab(teamTab, "team");
        void this.renderTeam(contentEl);
        break;
      case "chat":
        setActiveTab(chatTab, "chat");
        void this.renderChat(contentEl);
        break;
      case "reminders":
        setActiveTab(remindersTab, "reminders");
        void this.renderReminders(contentEl);
        break;
      case "inbox":
      default:
        setActiveTab(inboxTab, "inbox");
        void this.renderInbox(contentEl);
        break;
    }
  }
  async renderInbox(container) {
    await Promise.resolve();
    container.empty();
    container.removeClass("collab-chat-container");
    const allMentions = this.mentionParser.getAllMentionsForCurrentUser();
    const unreadCount = allMentions.filter((m) => !m.read).length;
    const readCount = allMentions.filter((m) => m.read).length;
    const headerRow = container.createEl("div", { cls: "collab-inbox-header" });
    const filterWrapper = headerRow.createEl("div", { cls: "collab-inbox-filter-wrapper" });
    filterWrapper.createEl("span", { text: "Show: ", cls: "collab-inbox-filter-label" });
    const filterSelect = filterWrapper.createEl("select", { cls: "collab-inbox-filter-select" });
    const allOption = filterSelect.createEl("option", { text: `All (${allMentions.length})`, attr: { value: "all" } });
    const unreadOption = filterSelect.createEl("option", { text: `Unread (${unreadCount})`, attr: { value: "unread" } });
    const readOption = filterSelect.createEl("option", { text: `Read (${readCount})`, attr: { value: "read" } });
    filterSelect.value = this.inboxFilter;
    filterSelect.addEventListener("change", () => {
      this.inboxFilter = filterSelect.value;
      void this.renderInbox(container);
    });
    const actionWrapper = headerRow.createEl("div", { cls: "collab-inbox-actions" });
    const refreshBtn = actionWrapper.createEl("button", {
      text: "\u{1F504}",
      cls: "collab-btn-small collab-refresh-btn",
      attr: { title: "Refresh" }
    });
    refreshBtn.addEventListener("click", () => {
      void (async () => {
        await this.mentionParser.loadMentions();
        await this.renderInbox(container);
        new import_obsidian4.Notice("Inbox refreshed");
      })();
    });
    if (unreadCount > 0) {
      const markAllBtn = actionWrapper.createEl("button", {
        text: "Mark all read",
        cls: "collab-btn-small"
      });
      markAllBtn.addEventListener("click", () => {
        void (async () => {
          await this.mentionParser.markAllAsRead();
          await this.renderInbox(container);
        })();
      });
    }
    if (unreadCount > 0) {
      const badge = container.createEl("div", { cls: "collab-unread-badge" });
      badge.createEl("span", { text: `${unreadCount} unread mention${unreadCount !== 1 ? "s" : ""}` });
    }
    let filteredMentions = allMentions;
    if (this.inboxFilter === "unread") {
      filteredMentions = allMentions.filter((m) => !m.read);
    } else if (this.inboxFilter === "read") {
      filteredMentions = allMentions.filter((m) => m.read);
    }
    if (filteredMentions.length === 0) {
      const emptyText = this.inboxFilter === "unread" ? "No unread mentions." : this.inboxFilter === "read" ? "No read mentions." : "No mentions yet.";
      container.createEl("div", {
        text: emptyText,
        cls: "collab-empty-state"
      });
      return;
    }
    for (const mention of filteredMentions) {
      this.renderMentionItem(container, mention, "inbox");
    }
  }
  async renderSent(container) {
    await Promise.resolve();
    container.empty();
    container.removeClass("collab-chat-container");
    const headerRow = container.createEl("div", { cls: "collab-inbox-header" });
    headerRow.createEl("span", { text: "Sent mentions", cls: "collab-inbox-title" });
    const refreshBtn = headerRow.createEl("button", {
      text: "\u{1F504}",
      cls: "collab-btn-small collab-refresh-btn",
      attr: { title: "Refresh" }
    });
    refreshBtn.addEventListener("click", () => {
      void (async () => {
        await this.mentionParser.loadMentions();
        await this.renderSent(container);
        new import_obsidian4.Notice("Sent refreshed");
      })();
    });
    const mentions = this.mentionParser.getMentionsFromCurrentUser();
    if (mentions.length === 0) {
      container.createEl("div", {
        text: "You haven't mentioned anyone yet.",
        cls: "collab-empty-state"
      });
      return;
    }
    for (const mention of mentions) {
      this.renderMentionItem(container, mention, "sent");
    }
  }
  async renderTeam(container) {
    container.empty();
    container.removeClass("collab-chat-container");
    const headerRow = container.createEl("div", { cls: "collab-inbox-header" });
    headerRow.createEl("span", { text: "Team members", cls: "collab-inbox-title" });
    const refreshBtn = headerRow.createEl("button", {
      text: "\u{1F504}",
      cls: "collab-btn-small collab-refresh-btn",
      attr: { title: "Refresh" }
    });
    refreshBtn.addEventListener("click", () => {
      void (async () => {
        await this.userManager.loadPresence();
        await this.userManager.loadUsers();
        await this.renderTeam(container);
        new import_obsidian4.Notice("Team refreshed");
      })();
    });
    await this.userManager.loadPresence();
    const usersWithStatus = this.userManager.getAllUsersWithStatus();
    const currentUser = this.userManager.getCurrentUser();
    if (currentUser) {
      const statusSection = container.createEl("div", { cls: "collab-status-selector-section" });
      const statusLabel = statusSection.createEl("span", {
        text: "Your status:",
        cls: "collab-status-selector-label"
      });
      const statusSelect = statusSection.createEl("select", { cls: "collab-status-selector" });
      const currentManualStatus = this.userManager.getCurrentUserManualStatus();
      const statusOptions = [
        { value: "auto", label: "\u{1F916} Automatic" },
        { value: "active", label: "\u{1F7E2} Active" },
        { value: "snooze", label: "\u{1F7E1} Snooze" },
        { value: "offline", label: "\u26AB Appear Offline" }
      ];
      for (const opt of statusOptions) {
        const option = statusSelect.createEl("option", {
          value: opt.value,
          text: opt.label
        });
        if (opt.value === currentManualStatus) {
          option.selected = true;
        }
      }
      statusSelect.addEventListener("change", () => {
        void (async () => {
          await this.userManager.setManualStatus(statusSelect.value);
          await this.renderTeam(container);
        })();
      });
    }
    if (usersWithStatus.length === 0) {
      container.createEl("div", {
        text: "No team members registered yet.",
        cls: "collab-empty-state"
      });
      return;
    }
    const statusOrder = { active: 0, snooze: 1, offline: 2 };
    usersWithStatus.sort((a, b) => statusOrder[a.status] - statusOrder[b.status]);
    const active = usersWithStatus.filter((u) => u.status === "active");
    const snooze = usersWithStatus.filter((u) => u.status === "snooze");
    const offline = usersWithStatus.filter((u) => u.status === "offline");
    if (active.length > 0) {
      container.createEl("div", { text: `Active (${active.length})`, cls: "collab-team-section-header" });
      for (const user of active) {
        this.renderTeamMember(container, user, (currentUser == null ? void 0 : currentUser.vaultName) === user.vaultName);
      }
    }
    if (snooze.length > 0) {
      container.createEl("div", { text: `Snooze (${snooze.length})`, cls: "collab-team-section-header" });
      for (const user of snooze) {
        this.renderTeamMember(container, user, (currentUser == null ? void 0 : currentUser.vaultName) === user.vaultName);
      }
    }
    if (offline.length > 0) {
      container.createEl("div", { text: `Offline (${offline.length})`, cls: "collab-team-section-header" });
      for (const user of offline) {
        this.renderTeamMember(container, user, (currentUser == null ? void 0 : currentUser.vaultName) === user.vaultName);
      }
    }
  }
  async renderReminders(container) {
    container.empty();
    container.removeClass("collab-chat-container");
    await this.reminderManager.loadReminders();
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return;
    const headerEl = container.createEl("div", { cls: "collab-reminders-header" });
    headerEl.createEl("h3", { text: "Reminders" });
    const addBtn = headerEl.createEl("button", {
      text: "New reminder +",
      cls: "collab-reminder-add-btn"
    });
    addBtn.addEventListener("click", () => {
      new NewReminderModal(this.app, this.reminderManager, () => {
        void (async () => {
          await this.renderReminders(container);
        })();
      }).open();
    });
    const pastDue = this.reminderManager.getPastDueReminders();
    if (pastDue.length > 0) {
      container.createEl("div", { text: `\u26A0\uFE0F Overdue (${pastDue.length})`, cls: "collab-reminder-section-header overdue" });
      for (const reminder of pastDue) {
        this.renderReminderItem(container, reminder, () => {
          void (async () => {
            await this.renderReminders(container);
          })();
        });
      }
    }
    const upcoming = this.reminderManager.getUpcomingReminders();
    if (upcoming.length > 0) {
      container.createEl("div", { text: `Upcoming (${upcoming.length})`, cls: "collab-reminder-section-header" });
      for (const reminder of upcoming) {
        this.renderReminderItem(container, reminder, () => {
          void (async () => {
            await this.renderReminders(container);
          })();
        });
      }
    }
    const completed = this.reminderManager.getCompletedReminders();
    if (completed.length > 0) {
      const completedHeader = container.createEl("div", {
        text: `\u2713 Completed (${completed.length})`,
        cls: "collab-reminder-section-header completed collapsible"
      });
      const completedContainer = container.createEl("div", { cls: "collab-reminder-completed-list collapsed" });
      completedHeader.addEventListener("click", () => {
        completedContainer.toggleClass("collapsed", !completedContainer.hasClass("collapsed"));
        completedHeader.toggleClass("expanded", !completedContainer.hasClass("collapsed"));
      });
      for (const reminder of completed.slice(0, 10)) {
        this.renderReminderItem(completedContainer, reminder, () => {
          void (async () => {
            await this.renderReminders(container);
          })();
        }, true);
      }
    }
    if (pastDue.length === 0 && upcoming.length === 0 && completed.length === 0) {
      container.createEl("div", {
        text: "No reminders yet. Create one to get started!",
        cls: "collab-empty-state"
      });
    }
  }
  renderReminderItem(container, reminder, onUpdate, isCompleted = false) {
    const isPastDue = !reminder.completed && new Date(reminder.dueDate) <= new Date();
    const priorityClass = reminder.priority !== "normal" ? `priority-${reminder.priority}` : "";
    const globalClass = reminder.isGlobal ? "global" : "";
    const itemEl = container.createEl("div", {
      cls: `collab-reminder-item ${isCompleted ? "completed" : ""} ${isPastDue ? "overdue" : ""} ${priorityClass} ${globalClass}`
    });
    const checkbox = itemEl.createEl("input", {
      cls: "collab-reminder-checkbox",
      attr: { type: "checkbox" }
    });
    checkbox.checked = reminder.completed;
    checkbox.addEventListener("change", () => {
      void (async () => {
        if (!reminder.completed) {
          await this.reminderManager.completeReminder(reminder.id);
          new import_obsidian4.Notice("Reminder completed! \u2713");
        }
        onUpdate();
      })();
    });
    const contentEl = itemEl.createEl("div", { cls: "collab-reminder-content" });
    contentEl.createEl("div", {
      text: reminder.message,
      cls: "collab-reminder-message"
    });
    const dueText = ReminderManager.formatDueDate(reminder.dueDate);
    const dueEl = contentEl.createEl("div", {
      text: dueText,
      cls: `collab-reminder-due ${isPastDue ? "overdue" : ""}`
    });
    if (reminder.priority !== "normal") {
      contentEl.createEl("span", {
        text: reminder.priority === "high" ? "\u{1F534} High" : "\u{1F535} Low",
        cls: "collab-reminder-priority"
      });
    }
    if (reminder.isGlobal) {
      contentEl.createEl("span", {
        text: "Team \u{1F310}",
        cls: "collab-reminder-global-badge"
      });
    }
    const actionsEl = itemEl.createEl("div", { cls: "collab-reminder-actions" });
    if (!isCompleted) {
      const snoozeBtn = actionsEl.createEl("button", {
        cls: "collab-reminder-action-btn",
        attr: { title: "Snooze" }
      });
      snoozeBtn.setText("\u23F0");
      snoozeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        new SnoozeModal(this.app, this.reminderManager, reminder.id, onUpdate).open();
      });
      const editBtn = actionsEl.createEl("button", {
        cls: "collab-reminder-action-btn",
        attr: { title: "Edit" }
      });
      editBtn.setText("\u270F\uFE0F");
      editBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        new EditReminderModal(this.app, this.reminderManager, reminder, onUpdate).open();
      });
    }
    const deleteBtn = actionsEl.createEl("button", {
      cls: "collab-reminder-action-btn",
      attr: { title: "Delete" }
    });
    deleteBtn.setText("\u{1F5D1}\uFE0F");
    deleteBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      void (async () => {
        await this.reminderManager.deleteReminder(reminder.id);
        onUpdate();
      })();
    });
  }
  renderTeamMember(container, user, isCurrentUser) {
    const itemEl = container.createEl("div", { cls: "collab-team-member" });
    const statusDot = itemEl.createEl("span", { cls: `collab-status-dot collab-status-${user.status}` });
    const infoEl = itemEl.createEl("div", { cls: "collab-team-info" });
    const nameEl = infoEl.createEl("div", { cls: "collab-team-name" });
    nameEl.createEl("span", {
      text: `@${user.vaultName}`,
      cls: "collab-username"
    });
    if (isCurrentUser) {
      nameEl.createEl("span", { text: " (you)", cls: "collab-you-tag" });
    }
    const userInfo2 = this.userManager.getUserByName(user.vaultName);
    if (userInfo2 == null ? void 0 : userInfo2.isAdmin) {
      nameEl.createEl("span", {
        text: userInfo2.adminLevel === "primary" ? " \u{1F451}" : " \u2B50",
        cls: "collab-admin-indicator",
        attr: { title: userInfo2.adminLevel === "primary" ? "Primary admin" : "Admin" }
      });
    }
    const statusText = this.getStatusText(user.status, user.lastSeen);
    infoEl.createEl("div", {
      text: statusText,
      cls: "collab-team-status-text"
    });
    const currentUserIsAdmin = this.userManager.isCurrentUserAdmin();
    const targetIsPrimaryAdmin = (userInfo2 == null ? void 0 : userInfo2.adminLevel) === "primary";
    if (currentUserIsAdmin && !isCurrentUser && !targetIsPrimaryAdmin) {
      const actionsEl = itemEl.createEl("div", { cls: "collab-team-member-actions" });
      const removeBtn = actionsEl.createEl("button", {
        text: "\u2715",
        cls: "collab-team-remove-btn",
        attr: { title: `Remove @${user.vaultName} from team` }
      });
      removeBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        new ConfirmActionModal(
          this.app,
          "Remove team member?",
          `Are you sure you want to remove @${user.vaultName} from the team?`,
          () => {
            void (async () => {
              await this.userManager.removeUser(user.vaultName);
              const teamContainer = container.parentElement;
              if (teamContainer) {
                await this.renderTeam(teamContainer);
              }
              new import_obsidian4.Notice(`@${user.vaultName} has been removed from the team`);
            })();
          }
        ).open();
      });
    }
  }
  getStatusText(status, lastSeen) {
    if (status === "active") {
      return "Active now";
    } else if (status === "snooze") {
      if (lastSeen) {
        return `Snoozing - last active ${this.formatDate(lastSeen)}`;
      }
      return "Snoozing";
    } else {
      if (lastSeen) {
        return `Offline - last seen ${this.formatDate(lastSeen)}`;
      }
      return "Offline";
    }
  }
  async renderChat(container) {
    container.empty();
    container.addClass("collab-chat-container");
    this.chatContainer = container;
    document.querySelectorAll(".collab-reaction-picker").forEach((el) => el.remove());
    await this.chatManager.loadChat();
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return;
    const channelListEl = container.createEl("div", { cls: "collab-channel-list" });
    const messagePaneEl = container.createEl("div", { cls: "collab-message-pane" });
    this.renderChannelList(channelListEl, currentUser.vaultName);
    await this.renderMessagePane(messagePaneEl, currentUser.vaultName);
  }
  renderChannelList(container, currentUser) {
    if (this.channelListCollapsed) {
      container.addClass("collapsed");
    }
    const headerEl = container.createEl("div", { cls: "collab-channel-header" });
    const collapseBtn = headerEl.createEl("button", {
      cls: "collab-channel-collapse-btn",
      text: this.channelListCollapsed ? "\xBB" : "\xAB"
    });
    collapseBtn.setAttribute("title", this.channelListCollapsed ? "Expand channels" : "Collapse channels");
    collapseBtn.addEventListener("click", () => {
      void (async () => {
        this.channelListCollapsed = !this.channelListCollapsed;
        if (this.chatContainer) {
          await this.renderChat(this.chatContainer);
        }
      })();
    });
    if (!this.channelListCollapsed) {
      headerEl.createEl("span", { text: "Channels", cls: "collab-channel-header-text" });
      const newBtn = headerEl.createEl("button", {
        cls: "collab-channel-new-btn",
        text: "+"
      });
      newBtn.setAttribute("title", "New channel or dm");
      newBtn.addEventListener("click", () => this.showNewChannelModal());
      const listEl = container.createEl("div", { cls: "collab-channel-items" });
      const channels = this.chatManager.getChannelsForUser(currentUser);
      const sortedChannels = this.sortChannels(channels, currentUser);
      for (const channel of sortedChannels) {
        this.renderChannelItem(listEl, channel, currentUser);
      }
    }
  }
  renderChannelItem(container, channel, currentUser) {
    const activeChannelId = this.chatManager.getActiveChannelId();
    const isActive = channel.id === activeChannelId;
    const isMuted = this.chatManager.isChannelMuted(channel.id);
    const itemEl = container.createEl("div", {
      cls: `collab-channel-item ${isActive ? "active" : ""} ${isMuted ? "muted" : ""}`
    });
    const leftEl = itemEl.createEl("div", { cls: "collab-channel-left" });
    const iconEl = leftEl.createEl("span", { cls: "collab-channel-icon" });
    iconEl.setText(channel.type === "dm" ? "@" : "#");
    const contentEl = leftEl.createEl("div", { cls: "collab-channel-content" });
    const nameRowEl = contentEl.createEl("div", { cls: "collab-channel-name-row" });
    const nameEl = nameRowEl.createEl("span", { cls: "collab-channel-name" });
    if (channel.type === "dm") {
      const otherMembers = channel.members.filter((m) => m !== currentUser);
      nameEl.setText(otherMembers.join(", ") || "Empty DM");
    } else {
      nameEl.setText(channel.name);
    }
    if (isMuted) {
      nameRowEl.createEl("span", { cls: "collab-channel-muted-icon", text: "\u{1F507}" });
    }
    const hasChannelMention = this.chatManager.hasUnreadChannelMention(channel.id, currentUser);
    if (hasChannelMention) {
      nameRowEl.createEl("span", { cls: "collab-channel-mention-icon", text: "@" });
    }
    const messages = this.chatManager.getMessages(channel.id);
    const lastMsg = messages[messages.length - 1];
    if (lastMsg && !lastMsg.deleted) {
      const previewEl = contentEl.createEl("div", { cls: "collab-channel-preview" });
      const previewText = lastMsg.from === "system" ? lastMsg.message : `${lastMsg.from}: ${lastMsg.message}`;
      previewEl.setText(this.truncate(previewText, 30));
    }
    const unreadCount = this.chatManager.getUnreadCount(channel.id, currentUser);
    if (unreadCount > 0 && !isMuted) {
      itemEl.createEl("span", {
        cls: "collab-channel-unread",
        text: unreadCount > 99 ? "99+" : String(unreadCount)
      });
    }
    itemEl.addEventListener("click", () => {
      void (async () => {
        this.chatManager.setActiveChannel(channel.id);
        if (this.chatContainer) {
          await this.renderChat(this.chatContainer);
        }
      })();
    });
  }
  sortChannels(channels, currentUser) {
    return [...channels].sort((a, b) => {
      if (a.id === GENERAL_CHANNEL_ID)
        return -1;
      if (b.id === GENERAL_CHANNEL_ID)
        return 1;
      if (a.type === "group" && b.type === "dm")
        return -1;
      if (a.type === "dm" && b.type === "group")
        return 1;
      const aMessages = this.chatManager.getMessages(a.id);
      const bMessages = this.chatManager.getMessages(b.id);
      const aLastMsg = aMessages[aMessages.length - 1];
      const bLastMsg = bMessages[bMessages.length - 1];
      const aTime = aLastMsg ? new Date(aLastMsg.timestamp).getTime() : new Date(a.createdAt).getTime();
      const bTime = bLastMsg ? new Date(bLastMsg.timestamp).getTime() : new Date(b.createdAt).getTime();
      return bTime - aTime;
    });
  }
  async renderMessagePane(container, currentUser) {
    const activeChannelId = this.chatManager.getActiveChannelId();
    const channel = this.chatManager.getChannel(activeChannelId);
    if (!channel) {
      container.createEl("div", {
        text: "Select a channel",
        cls: "collab-empty-state"
      });
      return;
    }
    await this.chatManager.markAsRead(activeChannelId);
    if (this.onBadgeUpdate) {
      this.onBadgeUpdate();
    }
    const headerEl = container.createEl("div", { cls: "collab-message-header" });
    const titleEl = headerEl.createEl("h3", { cls: "collab-message-title" });
    if (channel.type === "dm") {
      const others = channel.members.filter((m) => m !== currentUser);
      titleEl.setText(others.join(", ") || "Empty DM");
    } else {
      titleEl.setText(channel.name);
    }
    const searchWrapper = headerEl.createEl("div", { cls: "collab-chat-search-wrapper" });
    const searchInput = searchWrapper.createEl("input", {
      cls: "collab-chat-search-input",
      attr: {
        type: "text",
        placeholder: "Search messages... \u{1F50D}",
        value: this.chatSearchQuery
      }
    });
    if (this.chatSearchQuery) {
      const clearBtn = searchWrapper.createEl("button", {
        cls: "collab-chat-search-clear",
        text: "\u2715"
      });
      clearBtn.addEventListener("click", () => {
        this.chatSearchQuery = "";
        this.chatSearchResults = [];
        if (this.chatContainer) {
          void this.renderChat(this.chatContainer);
        }
      });
    }
    let searchTimeout = null;
    searchInput.addEventListener("input", (e) => {
      const query = e.target.value;
      if (searchTimeout) {
        window.clearTimeout(searchTimeout);
      }
      searchTimeout = window.setTimeout(() => {
        this.chatSearchQuery = query;
        if (query.trim()) {
          this.chatSearchResults = this.chatManager.searchMessages(query);
        } else {
          this.chatSearchResults = [];
        }
        this.updateMessagesForSearch();
      }, 300);
    });
    const headerActionsEl = headerEl.createEl("div", { cls: "collab-message-header-actions" });
    const refreshBtn = headerActionsEl.createEl("button", {
      cls: "collab-header-btn collab-refresh-btn",
      text: "\u{1F504}",
      attr: { title: "Refresh chat" }
    });
    refreshBtn.addEventListener("click", () => {
      void (async () => {
        await this.chatManager.loadChat();
        if (this.chatContainer) {
          await this.renderChat(this.chatContainer);
        }
        new import_obsidian4.Notice("Chat refreshed");
      })();
    });
    if (channel.type !== "general") {
      headerActionsEl.createEl("span", {
        cls: "collab-message-members",
        text: `${channel.members.length} member${channel.members.length !== 1 ? "s" : ""}`
      });
      const isMuted = this.chatManager.isChannelMuted(channel.id);
      const muteBtn = headerActionsEl.createEl("button", {
        cls: "collab-header-btn collab-mute-btn",
        text: isMuted ? "\u{1F507} Muted" : "\u{1F514}"
      });
      muteBtn.setAttribute("title", isMuted ? "Unmute channel" : "Mute notifications");
      muteBtn.addEventListener("click", () => {
        void (async () => {
          await this.chatManager.toggleChannelMute(channel.id);
          if (this.chatContainer) {
            await this.renderChat(this.chatContainer);
          }
        })();
      });
      const addBtn = headerActionsEl.createEl("button", {
        cls: "collab-header-btn",
        text: "Add +"
      });
      addBtn.addEventListener("click", () => this.showAddMemberModal(channel));
      if (this.chatManager.canDeleteChannel(channel.id, currentUser)) {
        const deleteBtn = headerActionsEl.createEl("button", {
          cls: "collab-header-btn collab-delete-btn",
          text: "Delete"
        });
        deleteBtn.addEventListener("click", () => {
          const channelType = channel.type === "dm" ? "conversation" : "channel";
          new DeleteChannelModal(
            this.app,
            channelType,
            // Export and delete
            async () => {
              const exportPath = await this.chatManager.exportChannel(channel.id);
              if (exportPath) {
                new import_obsidian4.Notice(`Chat exported to: ${exportPath}`);
              }
              await this.chatManager.deleteChannel(channel.id);
              if (this.chatContainer) {
                await this.renderChat(this.chatContainer);
              }
            },
            // Delete only
            async () => {
              await this.chatManager.deleteChannel(channel.id);
              if (this.chatContainer) {
                await this.renderChat(this.chatContainer);
              }
            }
          ).open();
        });
      }
      const leaveBtn = headerActionsEl.createEl("button", {
        cls: "collab-header-btn collab-leave-btn",
        text: "Leave"
      });
      leaveBtn.addEventListener("click", () => {
        const channelType = channel.type === "dm" ? "conversation" : "channel";
        const isLastMember = this.chatManager.isLastMember(channel.id, currentUser);
        if (isLastMember) {
          new LeaveAsLastMemberModal(
            this.app,
            channelType,
            // Export and leave (deletes channel)
            async () => {
              const exportPath = await this.chatManager.exportChannel(channel.id);
              if (exportPath) {
                new import_obsidian4.Notice(`Chat exported to: ${exportPath}`);
              }
              await this.chatManager.leaveChannel(channel.id, currentUser);
              if (this.chatContainer) {
                await this.renderChat(this.chatContainer);
              }
            },
            // Leave without export (deletes channel)
            async () => {
              await this.chatManager.leaveChannel(channel.id, currentUser);
              if (this.chatContainer) {
                await this.renderChat(this.chatContainer);
              }
            }
          ).open();
        } else {
          new ConfirmActionModal(this.app, `Leave ${channelType}?`, `You will no longer see messages in this ${channelType}.`, () => {
            void (async () => {
              await this.chatManager.leaveChannel(channel.id, currentUser);
              if (this.chatContainer) {
                await this.renderChat(this.chatContainer);
              }
            })();
          }).open();
        }
      });
    }
    const messagesWrapper = container.createEl("div", { cls: "collab-chat-messages-wrapper" });
    this.messagesWrapper = messagesWrapper;
    const messagesEl = messagesWrapper.createEl("div", { cls: "collab-chat-messages" });
    this.messagesContainer = messagesEl;
    if (this.chatSearchQuery && this.chatSearchResults.length > 0) {
      const searchHeaderEl = messagesEl.createEl("div", { cls: "collab-search-results-header" });
      searchHeaderEl.createEl("span", { text: `Found ${this.chatSearchResults.length} result${this.chatSearchResults.length !== 1 ? "s" : ""} for "${this.chatSearchQuery}"` });
      let lastDate = null;
      let lastChannelId = null;
      for (const msg of this.chatSearchResults) {
        if (msg.channelId !== lastChannelId) {
          const channelSeparatorEl = messagesEl.createEl("div", { cls: "collab-search-channel-separator" });
          channelSeparatorEl.createEl("span", { text: `# ${msg.channelName}` });
          channelSeparatorEl.addEventListener("click", () => {
            this.chatManager.setActiveChannel(msg.channelId);
            this.chatSearchQuery = "";
            this.chatSearchResults = [];
            if (this.chatContainer) {
              void this.renderChat(this.chatContainer);
            }
          });
          lastChannelId = msg.channelId;
          lastDate = null;
        }
        const msgDate = this.getDateString(msg.timestamp);
        if (msgDate !== lastDate) {
          const separatorEl = messagesEl.createEl("div", { cls: "collab-date-separator" });
          separatorEl.createEl("span", { text: msgDate });
          lastDate = msgDate;
        }
        const msgEl = this.renderChatMessage(messagesEl, msg, currentUser === msg.from);
        if (msgEl) {
          msgEl.addClass("collab-search-result-message");
          msgEl.addEventListener("click", () => {
            this.chatManager.setActiveChannel(msg.channelId);
            this.chatSearchQuery = "";
            this.chatSearchResults = [];
            if (this.chatContainer) {
              void this.renderChat(this.chatContainer);
            }
          });
        }
      }
    } else if (this.chatSearchQuery && this.chatSearchResults.length === 0) {
      messagesEl.createEl("div", {
        text: `No messages found for "${this.chatSearchQuery}"`,
        cls: "collab-empty-state"
      });
    } else {
      const messages = this.chatManager.getMessages(activeChannelId);
      if (messages.length === 0) {
        messagesEl.createEl("div", {
          text: "No messages yet. Start the conversation!",
          cls: "collab-empty-state"
        });
      } else {
        let lastDate = null;
        for (const msg of messages) {
          const msgDate = this.getDateString(msg.timestamp);
          if (msgDate !== lastDate) {
            const separatorEl = messagesEl.createEl("div", { cls: "collab-date-separator" });
            separatorEl.createEl("span", { text: msgDate });
            lastDate = msgDate;
          }
          this.renderChatMessage(messagesEl, msg, currentUser === msg.from);
        }
      }
    }
    const jumpBtn = messagesWrapper.createEl("button", {
      cls: "collab-jump-to-bottom collab-hidden",
      text: "Jump to latest \u2193 "
    });
    messagesEl.addEventListener("scroll", () => {
      const isNearBottom = messagesEl.scrollHeight - messagesEl.scrollTop - messagesEl.clientHeight < 100;
      jumpBtn.toggleClass("collab-hidden", isNearBottom);
      jumpBtn.toggleClass("collab-visible", !isNearBottom);
    });
    jumpBtn.addEventListener("click", () => {
      messagesEl.scrollTop = messagesEl.scrollHeight;
      jumpBtn.addClass("collab-hidden");
      jumpBtn.removeClass("collab-visible");
    });
    messagesEl.scrollTop = messagesEl.scrollHeight;
    const imagePreviewArea = container.createEl("div", { cls: "collab-chat-image-preview" });
    this.updateImagePreview(imagePreviewArea);
    this.renderMessageInput(container, imagePreviewArea);
  }
  // Timeout for clearing typing status
  renderMessageInput(container, imagePreviewArea) {
    const typingIndicator = container.createEl("div", { cls: "collab-typing-indicator collab-hidden" });
    this.typingIndicatorEl = typingIndicator;
    this.updateTypingIndicator();
    const inputArea = container.createEl("div", { cls: "collab-chat-input-area" });
    this.inputAreaContainer = inputArea;
    this.imagePreviewContainer = imagePreviewArea;
    if (this.replyingTo) {
      const replyPreview = inputArea.createEl("div", { cls: "collab-reply-preview" });
      const replyText = replyPreview.createEl("div", { cls: "collab-reply-preview-text" });
      replyText.createEl("span", { text: `Replying to @${this.replyingTo.from}: `, cls: "collab-reply-preview-from" });
      replyText.createEl("span", { text: this.truncate(this.replyingTo.message, 50) });
      const cancelReply = replyPreview.createEl("button", {
        cls: "collab-reply-preview-cancel",
        text: "\u2715"
      });
      cancelReply.addEventListener("click", () => {
        this.replyingTo = null;
        this.updateInputArea();
      });
    }
    const inputWrapper = inputArea.createEl("div", { cls: "collab-chat-input-wrapper" });
    const textInput = inputWrapper.createEl("textarea", {
      cls: "collab-chat-input",
      attr: { placeholder: "Type a message... Use @name to mention someone" }
    });
    textInput.addEventListener("paste", (e) => {
      var _a;
      const items = (_a = e.clipboardData) == null ? void 0 : _a.items;
      if (!items)
        return;
      for (const item of Array.from(items)) {
        if (item.type.startsWith("image/")) {
          e.preventDefault();
          const blob = item.getAsFile();
          if (blob) {
            void (async () => {
              const image = await this.chatManager.saveImageFromClipboard(blob);
              if (image) {
                this.pendingImages.push(image);
                this.updateImagePreview(imagePreviewArea);
                new import_obsidian4.Notice("Image added to message");
              }
            })();
          }
          break;
        }
      }
    });
    const buttonRow = inputWrapper.createEl("div", { cls: "collab-chat-buttons" });
    const leftButtons = buttonRow.createEl("div", { cls: "collab-chat-buttons-left" });
    const fileLinkBtn = leftButtons.createEl("button", {
      cls: "collab-chat-btn",
      attr: { title: "Insert file link [[filename]]" }
    });
    fileLinkBtn.setText("\u{1F4C4}");
    fileLinkBtn.addEventListener("click", () => {
      new FileLinkModal(this.app, (filePath) => {
        const linkText = `[[${filePath}]]`;
        const cursorPos = textInput.selectionStart;
        const before = textInput.value.substring(0, cursorPos);
        const after = textInput.value.substring(cursorPos);
        textInput.value = before + linkText + after;
        textInput.focus();
        textInput.selectionStart = textInput.selectionEnd = cursorPos + linkText.length;
      }).open();
    });
    const imageBtn = leftButtons.createEl("button", {
      cls: "collab-chat-btn",
      attr: { title: "Attach image (or paste from clipboard)" }
    });
    imageBtn.setText("\u{1F5BC}\uFE0F");
    const imageInput = leftButtons.createEl("input", {
      attr: { type: "file", accept: "image/*", style: "display: none" }
    });
    imageBtn.addEventListener("click", () => imageInput.click());
    imageInput.addEventListener("change", () => {
      var _a;
      const file = (_a = imageInput.files) == null ? void 0 : _a[0];
      if (file) {
        void (async () => {
          const image = await this.chatManager.saveImage(file);
          if (image) {
            this.pendingImages.push(image);
            this.updateImagePreview(imagePreviewArea);
            new import_obsidian4.Notice("Image added to message");
          }
          imageInput.value = "";
        })();
      } else {
        imageInput.value = "";
      }
    });
    const mentionBtn = leftButtons.createEl("button", {
      cls: "collab-chat-btn",
      attr: { title: "Mention someone @name" }
    });
    mentionBtn.setText("@");
    mentionBtn.addEventListener("click", () => {
      new UserMentionModal(this.app, this.userManager, (username) => {
        const mentionText = `@${username} `;
        const cursorPos = textInput.selectionStart;
        const before = textInput.value.substring(0, cursorPos);
        const after = textInput.value.substring(cursorPos);
        textInput.value = before + mentionText + after;
        textInput.focus();
        textInput.selectionStart = textInput.selectionEnd = cursorPos + mentionText.length;
      }).open();
    });
    const sendBtn = buttonRow.createEl("button", {
      text: "Send",
      cls: "collab-chat-send-btn"
    });
    const sendMessage = async () => {
      var _a;
      const message = textInput.value.trim();
      if (!message && this.pendingImages.length === 0)
        return;
      await this.userManager.clearTyping();
      if (this.typingTimeout) {
        window.clearTimeout(this.typingTimeout);
        this.typingTimeout = null;
      }
      const fileLinks = ChatManager.extractFileLinks(message);
      await this.chatManager.sendMessage(
        message || "(image)",
        fileLinks.length > 0 ? fileLinks : void 0,
        this.pendingImages.length > 0 ? [...this.pendingImages] : void 0,
        void 0,
        // channelId - use active channel
        (_a = this.replyingTo) == null ? void 0 : _a.id
        // replyTo
      );
      textInput.value = "";
      this.pendingImages = [];
      this.replyingTo = null;
      if (this.chatContainer) {
        await this.renderChat(this.chatContainer);
      }
    };
    sendBtn.addEventListener("click", () => {
      void sendMessage();
    });
    textInput.addEventListener("input", () => {
      void (async () => {
        const activeChannelId = this.chatManager.getActiveChannelId();
        await this.userManager.setTyping(activeChannelId);
        if (this.typingTimeout) {
          window.clearTimeout(this.typingTimeout);
        }
        this.typingTimeout = window.setTimeout(() => {
          void (async () => {
            await this.userManager.clearTyping();
          })();
        }, 3e3);
      })();
    });
    textInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        void (async () => {
          await sendMessage();
        })();
      }
    });
  }
  /**
   * Update the typing indicator to show who's typing
   */
  updateTypingIndicator() {
    if (!this.typingIndicatorEl)
      return;
    const activeChannelId = this.chatManager.getActiveChannelId();
    const typingUsers = this.userManager.getTypingUsers(activeChannelId);
    if (typingUsers.length === 0) {
      this.typingIndicatorEl.addClass("collab-hidden");
      this.typingIndicatorEl.removeClass("collab-visible");
      return;
    }
    this.typingIndicatorEl.removeClass("collab-hidden");
    this.typingIndicatorEl.addClass("collab-visible");
    let text;
    if (typingUsers.length === 1) {
      text = `${typingUsers[0]} is typing...`;
    } else if (typingUsers.length === 2) {
      text = `${typingUsers[0]} and ${typingUsers[1]} are typing...`;
    } else {
      text = `${typingUsers.length} people are typing...`;
    }
    this.typingIndicatorEl.empty();
    this.typingIndicatorEl.createEl("span", { text: "\u2022\u2022\u2022", cls: "collab-typing-dots" });
    this.typingIndicatorEl.appendText(" " + text);
  }
  showNewChannelModal() {
    new NewChannelModal(this.app, this.userManager, this.chatManager, (channel) => {
      void (async () => {
        this.chatManager.setActiveChannel(channel.id);
        if (this.chatContainer) {
          await this.renderChat(this.chatContainer);
        }
      })();
    }).open();
  }
  showAddMemberModal(channel) {
    new AddMemberModal(this.app, this.userManager, this.chatManager, channel, () => {
      void (async () => {
        if (this.chatContainer) {
          await this.renderChat(this.chatContainer);
        }
      })();
    }).open();
  }
  updateImagePreview(container) {
    container.empty();
    if (this.pendingImages.length === 0) {
      container.addClass("collab-hidden");
      container.removeClass("collab-visible");
      return;
    }
    container.removeClass("collab-hidden");
    container.addClass("collab-visible");
    for (const img of this.pendingImages) {
      const previewItem = container.createEl("div", { cls: "collab-image-preview-item" });
      const imgEl = previewItem.createEl("img", {
        cls: "collab-image-preview-img",
        attr: { src: this.app.vault.adapter.getResourcePath(img.path) }
      });
      const removeBtn = previewItem.createEl("button", {
        cls: "collab-image-preview-remove",
        text: "\xD7"
      });
      removeBtn.addEventListener("click", () => {
        this.pendingImages = this.pendingImages.filter((i) => i.id !== img.id);
        this.updateImagePreview(container);
      });
    }
  }
  renderChatMessage(container, msg, isOwn) {
    var _a;
    const currentUser = this.userManager.getCurrentUser();
    const isMentioned = (_a = msg.mentions) == null ? void 0 : _a.some(
      (m) => m.toLowerCase() === (currentUser == null ? void 0 : currentUser.vaultName.toLowerCase())
    );
    if (msg.deleted) {
      const msgEl2 = container.createEl("div", {
        cls: "collab-chat-message deleted"
      });
      msgEl2.createEl("div", {
        text: "This message was deleted \u{1F5D1}\uFE0F",
        cls: "collab-chat-deleted-text"
      });
      return msgEl2;
    }
    if (msg.from === "system") {
      const msgEl2 = container.createEl("div", {
        cls: "collab-chat-message system"
      });
      const contentEl2 = msgEl2.createEl("span", { cls: "collab-system-msg-content" });
      const messageText = msg.message;
      const fileLinkRegex = /\[\[([^\]]+)\]\]/g;
      let lastIndex = 0;
      let match;
      while ((match = fileLinkRegex.exec(msg.message)) !== null) {
        if (match.index > lastIndex) {
          contentEl2.appendText(msg.message.slice(lastIndex, match.index));
        }
        const filePath = match[1];
        const linkEl = contentEl2.createEl("a", {
          text: match[0],
          cls: "collab-file-link",
          attr: { href: "#" }
        });
        linkEl.addEventListener("click", (e) => {
          e.preventDefault();
          const file = this.app.vault.getAbstractFileByPath(filePath);
          if (file instanceof import_obsidian4.TFile) {
            void (async () => {
              await this.app.workspace.getLeaf().openFile(file);
            })();
          }
        });
        lastIndex = match.index + match[0].length;
      }
      if (lastIndex < msg.message.length) {
        contentEl2.appendText(msg.message.slice(lastIndex));
      }
      return msgEl2;
    }
    const user = this.userManager.getUserByName(msg.from);
    const userColor = (user == null ? void 0 : user.color) || "#7c3aed";
    const msgEl = container.createEl("div", {
      cls: `collab-chat-message ${isOwn ? "own" : "other"} ${isMentioned ? "mentioned" : ""}`,
      attr: { "data-message-id": msg.id }
    });
    msgEl.style.setProperty("--user-color", userColor);
    const headerEl = msgEl.createEl("div", { cls: "collab-chat-msg-header" });
    const nameEl = headerEl.createEl("span", {
      text: isOwn ? "You" : `@${msg.from}`,
      cls: "collab-chat-msg-from"
    });
    nameEl.style.color = userColor;
    if (msg.replyTo) {
      const repliedMsg = this.chatManager.getMessageById(msg.replyTo);
      if (repliedMsg && !repliedMsg.deleted) {
        const replyRefEl = msgEl.createEl("div", { cls: "collab-message-reply-ref" });
        const replyUser = this.userManager.getUserByName(repliedMsg.from);
        const replyColor = (replyUser == null ? void 0 : replyUser.color) || "#7c3aed";
        replyRefEl.style.setProperty("--reply-user-color", replyColor);
        replyRefEl.createEl("span", {
          text: `\u21A9 @${repliedMsg.from}: `,
          cls: "collab-reply-ref-from"
        });
        replyRefEl.createEl("span", {
          text: this.truncate(repliedMsg.message, 40),
          cls: "collab-reply-ref-text"
        });
        replyRefEl.addEventListener("click", (e) => {
          e.stopPropagation();
          this.scrollToMessage(msg.replyTo);
        });
      } else if (repliedMsg == null ? void 0 : repliedMsg.deleted) {
        const replyRefEl = msgEl.createEl("div", { cls: "collab-message-reply-ref deleted" });
        replyRefEl.createEl("span", { text: "Original message was deleted \u21A9 " });
      }
    }
    const contentEl = msgEl.createEl("div", { cls: "collab-chat-msg-content" });
    this.renderMessageContent(contentEl, msg.message, isOwn);
    if (msg.edited) {
      contentEl.createEl("span", {
        text: " (edited)",
        cls: "collab-chat-edited"
      });
    }
    if (msg.images && msg.images.length > 0) {
      const imagesEl = msgEl.createEl("div", { cls: "collab-chat-images" });
      for (const img of msg.images) {
        const imgWrapper = imagesEl.createEl("div", { cls: "collab-chat-image-wrapper" });
        const imgEl = imgWrapper.createEl("img", {
          cls: "collab-chat-image",
          attr: { src: this.app.vault.adapter.getResourcePath(img.path) }
        });
        imgEl.addEventListener("click", () => {
          this.openImageModal(img.path);
        });
      }
    }
    if (msg.reactions && msg.reactions.length > 0) {
      const reactionsEl = msgEl.createEl("div", { cls: "collab-chat-reactions" });
      for (const reaction of msg.reactions) {
        const reactionBtn = reactionsEl.createEl("button", {
          cls: "collab-chat-reaction-btn"
        });
        reactionBtn.createEl("span", { text: reaction.emoji });
        reactionBtn.createEl("span", {
          text: reaction.users.length.toString(),
          cls: "collab-reaction-count"
        });
        if (currentUser && reaction.users.includes(currentUser.vaultName)) {
          reactionBtn.addClass("reacted");
        }
        reactionBtn.setAttribute("title", reaction.users.join(", "));
        reactionBtn.addEventListener("click", () => {
          void (async () => {
            await this.chatManager.toggleReaction(msg.id, reaction.emoji);
            if (this.chatContainer) {
              await this.renderChat(this.chatContainer);
            }
          })();
        });
      }
    }
    const footerEl = msgEl.createEl("div", { cls: "collab-chat-msg-footer" });
    footerEl.createEl("span", {
      text: this.formatDate(msg.timestamp),
      cls: "collab-chat-msg-time"
    });
    const actionsEl = footerEl.createEl("div", { cls: "collab-chat-msg-actions" });
    const replyBtn = actionsEl.createEl("button", {
      cls: "collab-chat-action-btn",
      attr: { title: "Reply" }
    });
    replyBtn.setText("\u21A9\uFE0F");
    replyBtn.addEventListener("click", (e) => {
      var _a2;
      e.stopPropagation();
      this.replyingTo = msg;
      this.updateInputArea();
      const inputEl = (_a2 = this.chatContainer) == null ? void 0 : _a2.querySelector(".collab-chat-input");
      if (inputEl)
        inputEl.focus();
    });
    const addReactionBtn = actionsEl.createEl("button", {
      cls: "collab-chat-action-btn",
      attr: { title: "Add reaction" }
    });
    addReactionBtn.setText("\u{1F60A}");
    addReactionBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      this.showReactionPicker(msg.id, addReactionBtn);
    });
    if (isOwn) {
      const editBtn = actionsEl.createEl("button", {
        cls: "collab-chat-action-btn",
        attr: { title: "Edit message" }
      });
      editBtn.setText("\u270F\uFE0F");
      editBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        new EditMessageModal(this.app, msg.message, (newContent) => {
          void (async () => {
            await this.chatManager.editMessage(msg.id, newContent);
            if (this.chatContainer) {
              await this.renderChat(this.chatContainer);
            }
          })();
        }).open();
      });
      const deleteBtn = actionsEl.createEl("button", {
        cls: "collab-chat-action-btn",
        attr: { title: "Delete message" }
      });
      deleteBtn.setText("\u{1F5D1}\uFE0F");
      deleteBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        new ConfirmDeleteModal(this.app, () => {
          void (async () => {
            await this.chatManager.deleteMessage(msg.id);
            if (this.chatContainer) {
              await this.renderChat(this.chatContainer);
            }
          })();
        }).open();
      });
    }
    return msgEl;
  }
  showReactionPicker(messageId, anchorEl) {
    const picker = document.createElement("div");
    picker.className = "collab-reaction-picker";
    for (const emoji of ChatManager.QUICK_REACTIONS) {
      const btn = document.createElement("button");
      btn.className = "collab-reaction-picker-btn";
      btn.textContent = emoji;
      btn.addEventListener("click", () => {
        void (async () => {
          await this.chatManager.toggleReaction(messageId, emoji);
          picker.remove();
          if (this.chatContainer) {
            await this.renderChat(this.chatContainer);
          }
        })();
      });
      picker.appendChild(btn);
    }
    picker.addClass("collab-position-fixed");
    picker.addClass("collab-visibility-hidden");
    document.body.appendChild(picker);
    const rect = anchorEl.getBoundingClientRect();
    const pickerRect = picker.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    let top = rect.top - pickerRect.height - 8;
    let left = rect.left;
    if (top < 8) {
      top = rect.bottom + 8;
    }
    if (left + pickerRect.width > viewportWidth - 8) {
      left = viewportWidth - pickerRect.width - 8;
    }
    if (left < 8) {
      left = 8;
    }
    picker.setCssProps({ "--picker-left": `${left}px`, "--picker-top": `${top}px` });
    picker.removeClass("collab-visibility-hidden");
    picker.addClass("collab-visibility-visible");
    const closeHandler = (e) => {
      if (!picker.contains(e.target)) {
        picker.remove();
        document.removeEventListener("click", closeHandler);
      }
    };
    setTimeout(() => document.addEventListener("click", closeHandler), 0);
  }
  renderMessageContent(container, message, isOwn) {
    const combinedRegex = /(\[\[[^\]]+\]\])|(@#[\w-]+)|(@\w+)|(https?:\/\/[^\s<>[\]]+)/g;
    let lastIndex = 0;
    let match;
    while ((match = combinedRegex.exec(message)) !== null) {
      if (match.index > lastIndex) {
        container.createEl("span", { text: message.substring(lastIndex, match.index) });
      }
      const matchedText = match[0];
      if (matchedText.startsWith("[[")) {
        const filePath = matchedText.slice(2, -2);
        const link = container.createEl("a", {
          text: `\u{1F4C4} ${filePath}`,
          cls: "collab-chat-file-link"
        });
        link.addEventListener("click", (e) => {
          e.preventDefault();
          void (async () => {
            await this.openFile(filePath);
          })();
        });
      } else if (matchedText.startsWith("@#")) {
        const channelName = matchedText.substring(2);
        const channelMentionEl = container.createEl("span", {
          text: matchedText,
          cls: "collab-chat-channel-mention"
        });
        channelMentionEl.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          const currentUser = this.userManager.getCurrentUser();
          if (currentUser) {
            const channels = this.chatManager.getChannelsForUser(currentUser.vaultName);
            const channel = channels.find((ch) => ch.name.toLowerCase() === channelName.toLowerCase());
            if (channel) {
              this.chatManager.setActiveChannel(channel.id);
              const container2 = this.chatContainer;
              if (container2) {
                void (async () => {
                  await this.renderChat(container2);
                })();
              }
            }
          }
        });
      } else if (matchedText.startsWith("@")) {
        const username = matchedText.substring(1);
        const user = this.userManager.getUserByName(username);
        const mentionEl = container.createEl("span", {
          text: matchedText,
          cls: "collab-chat-mention"
        });
        if (user == null ? void 0 : user.color) {
          mentionEl.style.setProperty("--mention-color", user.color);
        }
        const currentUser = this.userManager.getCurrentUser();
        if (currentUser && username.toLowerCase() === currentUser.vaultName.toLowerCase()) {
          mentionEl.addClass("collab-chat-mention-me");
        }
      } else if (matchedText.startsWith("http")) {
        const link = container.createEl("a", {
          text: this.truncateUrl(matchedText),
          cls: "collab-chat-url",
          attr: { href: matchedText, target: "_blank", rel: "noopener" }
        });
      }
      lastIndex = match.index + matchedText.length;
    }
    if (lastIndex < message.length) {
      container.createEl("span", { text: message.substring(lastIndex) });
    }
  }
  truncateUrl(url) {
    if (url.length > 50) {
      return url.substring(0, 47) + "...";
    }
    return url;
  }
  openImageModal(imagePath) {
    const modal = document.createElement("div");
    modal.className = "collab-image-modal";
    const content = document.createElement("div");
    content.className = "collab-image-modal-content";
    const img = document.createElement("img");
    img.src = this.app.vault.adapter.getResourcePath(imagePath);
    const closeBtn = document.createElement("button");
    closeBtn.className = "collab-image-modal-close";
    closeBtn.textContent = "\xD7";
    content.appendChild(img);
    content.appendChild(closeBtn);
    modal.appendChild(content);
    modal.addEventListener("click", (e) => {
      if (e.target === modal || e.target.classList.contains("collab-image-modal-close")) {
        modal.remove();
      }
    });
    document.body.appendChild(modal);
  }
  async openFile(path) {
    let file = this.app.vault.getAbstractFileByPath(path);
    if (!file) {
      const files = this.app.vault.getFiles();
      file = files.find((f) => f.path === path || f.name === path || f.basename === path) || null;
    }
    if (file && file instanceof import_obsidian4.TFile) {
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(file);
    }
  }
  /**
   * Refresh only the chat messages without destroying input (called from outside)
   */
  async refreshChat() {
    var _a, _b;
    if (this.activeTab !== "chat") {
      return;
    }
    if (this.isRefreshing)
      return;
    this.isRefreshing = true;
    try {
      const inputEl = (_a = this.chatContainer) == null ? void 0 : _a.querySelector(".collab-chat-input");
      const hadFocus = document.activeElement === inputEl;
      const inputValue = (inputEl == null ? void 0 : inputEl.value) || "";
      const selectionStart = (inputEl == null ? void 0 : inputEl.selectionStart) || 0;
      const selectionEnd = (inputEl == null ? void 0 : inputEl.selectionEnd) || 0;
      if (this.messagesContainer) {
        await this.chatManager.loadChat();
        await this.refreshMessagesOnly();
      } else if (this.chatContainer) {
        await this.renderChat(this.chatContainer);
      }
      this.updateTypingIndicator();
      const newInputEl = (_b = this.chatContainer) == null ? void 0 : _b.querySelector(".collab-chat-input");
      if (newInputEl && inputValue) {
        newInputEl.value = inputValue;
        if (hadFocus) {
          newInputEl.focus();
          newInputEl.setSelectionRange(selectionStart, selectionEnd);
        }
      }
    } finally {
      this.isRefreshing = false;
    }
  }
  /**
   * Refresh only the messages area without touching input
   */
  async refreshMessagesOnly() {
    var _a;
    await Promise.resolve();
    if (!this.messagesContainer)
      return;
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return;
    const activeChannelId = this.chatManager.getActiveChannelId();
    const messages = this.chatManager.getMessages(activeChannelId);
    const wasNearBottom = this.messagesContainer.scrollHeight - this.messagesContainer.scrollTop - this.messagesContainer.clientHeight < 100;
    this.messagesContainer.empty();
    if (messages.length === 0) {
      this.messagesContainer.createEl("div", {
        text: "No messages yet. Start the conversation!",
        cls: "collab-empty-state"
      });
    } else {
      let lastDate = null;
      for (const msg of messages) {
        const msgDate = this.getDateString(msg.timestamp);
        if (msgDate !== lastDate) {
          const separatorEl = this.messagesContainer.createEl("div", { cls: "collab-date-separator" });
          separatorEl.createEl("span", { text: msgDate });
          lastDate = msgDate;
        }
        this.renderChatMessage(this.messagesContainer, msg, currentUser.vaultName === msg.from);
      }
    }
    if (wasNearBottom) {
      this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    }
    const channelListEl = (_a = this.chatContainer) == null ? void 0 : _a.querySelector(".collab-channel-items");
    if (channelListEl) {
      channelListEl.empty();
      const channels = this.chatManager.getChannelsForUser(currentUser.vaultName);
      const sortedChannels = this.sortChannels(channels, currentUser.vaultName);
      for (const channel of sortedChannels) {
        this.renderChannelItem(channelListEl, channel, currentUser.vaultName);
      }
    }
  }
  /**
   * Update only the messages area for search results without re-rendering the entire chat
   * This preserves the search input focus
   */
  updateMessagesForSearch() {
    if (!this.messagesContainer)
      return;
    const currentUser = this.userManager.getCurrentUser();
    if (!currentUser)
      return;
    this.messagesContainer.empty();
    if (this.chatSearchQuery && this.chatSearchResults.length > 0) {
      const searchHeaderEl = this.messagesContainer.createEl("div", { cls: "collab-search-results-header" });
      searchHeaderEl.createEl("span", { text: `Found ${this.chatSearchResults.length} result${this.chatSearchResults.length !== 1 ? "s" : ""} for "${this.chatSearchQuery}"` });
      let lastDate = null;
      let lastChannelId = null;
      for (const msg of this.chatSearchResults) {
        if (msg.channelId !== lastChannelId) {
          const channelSeparatorEl = this.messagesContainer.createEl("div", { cls: "collab-search-channel-separator" });
          channelSeparatorEl.createEl("span", { text: `# ${msg.channelName}` });
          channelSeparatorEl.addEventListener("click", () => {
            this.chatManager.setActiveChannel(msg.channelId);
            this.chatSearchQuery = "";
            this.chatSearchResults = [];
            if (this.chatContainer) {
              void this.renderChat(this.chatContainer);
            }
          });
          lastChannelId = msg.channelId;
          lastDate = null;
        }
        const msgDate = this.getDateString(msg.timestamp);
        if (msgDate !== lastDate) {
          const separatorEl = this.messagesContainer.createEl("div", { cls: "collab-date-separator" });
          separatorEl.createEl("span", { text: msgDate });
          lastDate = msgDate;
        }
        const msgEl = this.renderChatMessage(this.messagesContainer, msg, currentUser.vaultName === msg.from);
        if (msgEl) {
          msgEl.addClass("collab-search-result-message");
          msgEl.addEventListener("click", () => {
            this.chatManager.setActiveChannel(msg.channelId);
            this.chatSearchQuery = "";
            this.chatSearchResults = [];
            if (this.chatContainer) {
              void this.renderChat(this.chatContainer);
            }
          });
        }
      }
    } else if (this.chatSearchQuery && this.chatSearchResults.length === 0) {
      this.messagesContainer.createEl("div", {
        text: `No messages found for "${this.chatSearchQuery}"`,
        cls: "collab-empty-state"
      });
    } else {
      const activeChannelId = this.chatManager.getActiveChannelId();
      const messages = this.chatManager.getMessages(activeChannelId);
      if (messages.length === 0) {
        this.messagesContainer.createEl("div", {
          text: "No messages yet. Start the conversation!",
          cls: "collab-empty-state"
        });
      } else {
        let lastDate = null;
        for (const msg of messages) {
          const msgDate = this.getDateString(msg.timestamp);
          if (msgDate !== lastDate) {
            const separatorEl = this.messagesContainer.createEl("div", { cls: "collab-date-separator" });
            separatorEl.createEl("span", { text: msgDate });
            lastDate = msgDate;
          }
          this.renderChatMessage(this.messagesContainer, msg, currentUser.vaultName === msg.from);
        }
      }
      this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
    }
  }
  /**
   * Update only the input area (for reply state changes) without touching messages
   */
  updateInputArea() {
    var _a;
    if (!this.inputAreaContainer || !this.imagePreviewContainer || !this.chatContainer)
      return;
    const oldInputEl = this.inputAreaContainer.querySelector(".collab-chat-input");
    const hadFocus = document.activeElement === oldInputEl;
    const inputValue = (oldInputEl == null ? void 0 : oldInputEl.value) || "";
    const selectionStart = (oldInputEl == null ? void 0 : oldInputEl.selectionStart) || 0;
    const selectionEnd = (oldInputEl == null ? void 0 : oldInputEl.selectionEnd) || 0;
    this.inputAreaContainer.remove();
    const messagePane = this.chatContainer.querySelector(".collab-message-pane");
    if (!messagePane)
      return;
    this.renderMessageInput(messagePane, this.imagePreviewContainer);
    const newInputEl = (_a = this.inputAreaContainer) == null ? void 0 : _a.querySelector(".collab-chat-input");
    if (newInputEl) {
      newInputEl.value = inputValue;
      if (hadFocus) {
        newInputEl.focus();
        newInputEl.setSelectionRange(selectionStart, selectionEnd);
      }
    }
  }
  /**
   * Scroll to a specific message by ID
   */
  scrollToMessage(messageId) {
    if (!this.messagesContainer)
      return;
    const msgEl = this.messagesContainer.querySelector(`[data-message-id="${messageId}"]`);
    if (msgEl) {
      msgEl.scrollIntoView({ behavior: "smooth", block: "center" });
      msgEl.addClass("collab-message-highlight");
      setTimeout(() => {
        msgEl.removeClass("collab-message-highlight");
      }, 1500);
    }
  }
  renderMentionItem(container, mention, type) {
    const itemEl = container.createEl("div", {
      cls: `collab-mention-item ${mention.read ? "" : "unread"}`
    });
    const headerEl = itemEl.createEl("div", { cls: "collab-mention-header" });
    if (type === "inbox") {
      headerEl.createEl("span", {
        text: `From @${mention.from}`,
        cls: "collab-mention-from"
      });
    } else {
      headerEl.createEl("span", {
        text: `To @${mention.to}`,
        cls: "collab-mention-to"
      });
    }
    headerEl.createEl("span", {
      text: this.formatDate(mention.timestamp),
      cls: "collab-mention-date"
    });
    if (type === "sent") {
      const statusEl = headerEl.createEl("span", {
        cls: "collab-mention-status"
      });
      if (mention.read && mention.readAt) {
        statusEl.setText(`\u2713 Read ${this.formatDate(mention.readAt)}`);
        statusEl.addClass("collab-status-read");
      } else {
        statusEl.setText("Unread");
        statusEl.addClass("collab-status-unread");
      }
    }
    itemEl.createEl("div", {
      text: this.truncate(mention.context, 100),
      cls: "collab-mention-context"
    });
    const fileEl = itemEl.createEl("div", { cls: "collab-mention-file" });
    const fileName = mention.file.split("/").pop() || mention.file;
    const link = fileEl.createEl("a", {
      text: `\u{1F4C4} ${fileName}:${mention.line + 1}`,
      cls: "collab-file-link"
    });
    link.addEventListener("click", (e) => {
      e.preventDefault();
      void (async () => {
        await this.openFileAtLine(mention.file, mention.line);
      })();
    });
    if (type === "inbox" && !mention.read) {
      const actionsEl = itemEl.createEl("div", { cls: "collab-mention-actions" });
      const markReadBtn = actionsEl.createEl("button", {
        text: "\u2713",
        cls: "collab-btn-icon",
        attr: { title: "Mark as read" }
      });
      markReadBtn.addEventListener("click", (e) => {
        e.stopPropagation();
        void (async () => {
          await this.mentionParser.markAsRead(mention.id);
          itemEl.removeClass("unread");
          markReadBtn.remove();
          if (this.onBadgeUpdate) {
            this.onBadgeUpdate();
          }
        })();
      });
    }
    if (mention.replies && mention.replies.length > 0) {
      const repliesEl = itemEl.createEl("div", { cls: "collab-replies" });
      repliesEl.createEl("span", {
        text: `\u{1F4AC} ${mention.replies.length} repl${mention.replies.length > 1 ? "ies" : "y"}`,
        cls: "collab-replies-count"
      });
    }
  }
  async openFileAtLine(path, line) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file && file instanceof import_obsidian4.TFile) {
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.openFile(file);
      setTimeout(() => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
        if (view && view.editor) {
          view.editor.setCursor({ line, ch: 0 });
          view.editor.scrollIntoView(
            { from: { line, ch: 0 }, to: { line, ch: 0 } },
            true
          );
        }
      }, 100);
    }
  }
  getDateString(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    const dateOnly = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    const todayOnly = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const yesterdayOnly = new Date(todayOnly);
    yesterdayOnly.setDate(yesterdayOnly.getDate() - 1);
    if (dateOnly.getTime() === todayOnly.getTime()) {
      return "Today";
    } else if (dateOnly.getTime() === yesterdayOnly.getTime()) {
      return "Yesterday";
    } else {
      return date.toLocaleDateString(void 0, {
        year: "numeric",
        month: "long",
        day: "numeric"
      });
    }
  }
  formatDate(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    const diff = now.getTime() - date.getTime();
    const minutes = Math.floor(diff / 6e4);
    const hours = Math.floor(diff / 36e5);
    const days = Math.floor(diff / 864e5);
    if (minutes < 1) {
      return "just now";
    } else if (minutes < 60) {
      return `${minutes}m`;
    } else if (hours < 24) {
      return `${hours}h`;
    } else if (days < 7) {
      return `${days}d`;
    } else {
      return date.toLocaleDateString();
    }
  }
  truncate(text, maxLength) {
    if (text.length <= maxLength)
      return text;
    return text.substring(0, maxLength - 3) + "...";
  }
  async onClose() {
  }
};
var FileLinkModal = class extends import_obsidian4.FuzzySuggestModal {
  constructor(app, onSelect) {
    super(app);
    this.onSelect = onSelect;
    this.setPlaceholder("Search for a file to link...");
  }
  getItems() {
    return this.app.vault.getMarkdownFiles();
  }
  getItemText(item) {
    return item.path;
  }
  onChooseItem(item, evt) {
    this.onSelect(item.path);
  }
};
var UserMentionModal = class extends import_obsidian4.FuzzySuggestModal {
  constructor(app, userManager, onSelect) {
    super(app);
    this.userManager = userManager;
    this.onSelect = onSelect;
    this.setPlaceholder("Search for a team member to mention...");
  }
  getItems() {
    const currentUser = this.userManager.getCurrentUser();
    const users = this.userManager.getAllUsers().filter(
      (u) => u.vaultName !== (currentUser == null ? void 0 : currentUser.vaultName)
    );
    const specialMentions = [
      { vaultName: "everyone", color: "#ef4444", isSpecial: true, description: "Notify all users" }
    ];
    return [...specialMentions, ...users];
  }
  getItemText(item) {
    if (item.description) {
      return `@${item.vaultName} \u2014 ${item.description}`;
    }
    return `@${item.vaultName}`;
  }
  onChooseItem(item, evt) {
    this.onSelect(item.vaultName);
  }
};
var EditMessageModal = class extends import_obsidian4.Modal {
  constructor(app, originalContent, onSave) {
    super(app);
    this.originalContent = originalContent;
    this.onSave = onSave;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("collab-edit-message-modal");
    contentEl.createEl("h3", { text: "Edit message" });
    const textarea = contentEl.createEl("textarea", {
      cls: "collab-edit-message-input",
      attr: { rows: "4" }
    });
    textarea.value = this.originalContent;
    const buttonRow = contentEl.createEl("div", { cls: "collab-edit-message-buttons" });
    const cancelBtn = buttonRow.createEl("button", {
      text: "Cancel",
      cls: "collab-edit-cancel-btn"
    });
    cancelBtn.addEventListener("click", () => this.close());
    const saveBtn = buttonRow.createEl("button", {
      text: "Save",
      cls: "collab-edit-save-btn"
    });
    saveBtn.addEventListener("click", () => {
      const newContent = textarea.value.trim();
      if (newContent && newContent !== this.originalContent) {
        this.onSave(newContent);
      }
      this.close();
    });
    setTimeout(() => textarea.focus(), 10);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var NewChannelModal = class extends import_obsidian4.Modal {
  constructor(app, userManager, chatManager, onCreated) {
    super(app);
    this.activeTab = "group";
    this.userManager = userManager;
    this.chatManager = chatManager;
    this.onCreated = onCreated;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("collab-new-channel-modal");
    contentEl.createEl("h3", { text: "New conversation" });
    const tabsEl = contentEl.createEl("div", { cls: "collab-modal-tabs" });
    const groupTab = tabsEl.createEl("button", { text: "Group channel", cls: "active" });
    const dmTab = tabsEl.createEl("button", { text: "Direct message" });
    const formEl = contentEl.createEl("div", { cls: "collab-modal-form" });
    const renderGroupForm = () => {
      formEl.empty();
      this.activeTab = "group";
      formEl.createEl("label", { text: "Channel name" });
      const nameInput = formEl.createEl("input", {
        attr: { type: "text", placeholder: "Example: project-alpha" }
      });
      formEl.createEl("label", { text: "Add members" });
      const membersContainer = formEl.createEl("div", { cls: "collab-member-select" });
      const currentUser = this.userManager.getCurrentUser();
      const allUsers = this.userManager.getAllUsers();
      const selectedMembers = currentUser ? [currentUser.vaultName] : [];
      for (const user of allUsers) {
        if (user.vaultName === (currentUser == null ? void 0 : currentUser.vaultName))
          continue;
        const checkboxLabel = membersContainer.createEl("label", { cls: "collab-member-checkbox" });
        const checkbox = checkboxLabel.createEl("input", { attr: { type: "checkbox" } });
        checkboxLabel.createEl("span", { text: `@${user.vaultName}` });
        checkbox.addEventListener("change", () => {
          if (checkbox.checked) {
            if (!selectedMembers.includes(user.vaultName)) {
              selectedMembers.push(user.vaultName);
            }
          } else {
            const idx = selectedMembers.indexOf(user.vaultName);
            if (idx > -1)
              selectedMembers.splice(idx, 1);
          }
        });
      }
      const createBtn = formEl.createEl("button", {
        text: "Create channel",
        cls: "collab-create-btn"
      });
      createBtn.addEventListener("click", () => {
        const name = nameInput.value.trim();
        if (!name) {
          new import_obsidian4.Notice("Please enter a channel name");
          return;
        }
        if (!currentUser)
          return;
        void (async () => {
          const channel = await this.chatManager.createGroupChannel(name, selectedMembers, currentUser.vaultName);
          this.close();
          this.onCreated(channel);
        })();
      });
    };
    const renderDMForm = () => {
      formEl.empty();
      this.activeTab = "dm";
      formEl.createEl("label", { text: "Select user" });
      const userSelect = formEl.createEl("select", { cls: "collab-user-select" });
      const currentUser = this.userManager.getCurrentUser();
      const allUsers = this.userManager.getAllUsers();
      for (const user of allUsers) {
        if (user.vaultName === (currentUser == null ? void 0 : currentUser.vaultName))
          continue;
        userSelect.createEl("option", { value: user.vaultName, text: `@${user.vaultName}` });
      }
      const startBtn = formEl.createEl("button", {
        text: "Start conversation",
        cls: "collab-create-btn"
      });
      startBtn.addEventListener("click", () => {
        const selectedUser = userSelect.value;
        if (!selectedUser || !currentUser)
          return;
        void (async () => {
          const channel = await this.chatManager.startDM(currentUser.vaultName, selectedUser);
          this.close();
          this.onCreated(channel);
        })();
      });
    };
    groupTab.addEventListener("click", () => {
      groupTab.addClass("active");
      dmTab.removeClass("active");
      renderGroupForm();
    });
    dmTab.addEventListener("click", () => {
      dmTab.addClass("active");
      groupTab.removeClass("active");
      renderDMForm();
    });
    renderGroupForm();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var AddMemberModal = class extends import_obsidian4.Modal {
  constructor(app, userManager, chatManager, channel, onAdded) {
    super(app);
    this.userManager = userManager;
    this.chatManager = chatManager;
    this.channel = channel;
    this.onAdded = onAdded;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("collab-add-member-modal");
    contentEl.createEl("h3", { text: "Add member" });
    contentEl.createEl("p", {
      text: `Current members: ${this.channel.members.join(", ")}`,
      cls: "collab-current-members"
    });
    if (this.channel.type === "dm") {
      contentEl.createEl("p", {
        text: "Adding a member will convert this dm to a group channel.",
        cls: "collab-warning-text"
      });
    }
    const currentUser = this.userManager.getCurrentUser();
    const allUsers = this.userManager.getAllUsers();
    const availableUsers = allUsers.filter((u) => !this.channel.members.includes(u.vaultName));
    if (availableUsers.length === 0) {
      contentEl.createEl("p", { text: "All team members are already in this channel." });
      return;
    }
    contentEl.createEl("label", { text: "Select user" });
    const userSelect = contentEl.createEl("select", { cls: "collab-user-select" });
    for (const user of availableUsers) {
      userSelect.createEl("option", { value: user.vaultName, text: `@${user.vaultName}` });
    }
    const addBtn = contentEl.createEl("button", {
      text: "Add member",
      cls: "collab-create-btn"
    });
    addBtn.addEventListener("click", () => {
      const selectedUser = userSelect.value;
      if (!selectedUser || !currentUser)
        return;
      void (async () => {
        await this.chatManager.addMemberToChannel(this.channel.id, selectedUser, currentUser.vaultName);
        this.close();
        this.onAdded();
      })();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ConfirmDeleteModal = class extends import_obsidian4.Modal {
  constructor(app, onConfirm) {
    super(app);
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("collab-confirm-modal");
    contentEl.createEl("h3", { text: "Delete message?" });
    contentEl.createEl("p", { text: "This action cannot be undone." });
    const buttonRow = contentEl.createEl("div", { cls: "collab-confirm-buttons" });
    const cancelBtn = buttonRow.createEl("button", {
      text: "Cancel",
      cls: "collab-confirm-cancel-btn"
    });
    cancelBtn.addEventListener("click", () => this.close());
    const confirmBtn = buttonRow.createEl("button", {
      text: "Delete",
      cls: "collab-confirm-delete-btn"
    });
    confirmBtn.addEventListener("click", () => {
      this.close();
      this.onConfirm();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ConfirmActionModal = class extends import_obsidian4.Modal {
  constructor(app, title, message, onConfirm) {
    super(app);
    this.title = title;
    this.message = message;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("collab-confirm-modal");
    contentEl.createEl("h3", { text: this.title });
    contentEl.createEl("p", { text: this.message });
    const buttonRow = contentEl.createEl("div", { cls: "collab-confirm-buttons" });
    const cancelBtn = buttonRow.createEl("button", {
      text: "Cancel",
      cls: "collab-confirm-cancel-btn"
    });
    cancelBtn.addEventListener("click", () => this.close());
    const confirmBtn = buttonRow.createEl("button", {
      text: "Confirm",
      cls: "collab-confirm-action-btn"
    });
    confirmBtn.addEventListener("click", () => {
      this.close();
      this.onConfirm();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var DeleteChannelModal = class extends import_obsidian4.Modal {
  constructor(app, channelType, onExportAndDelete, onDeleteOnly) {
    super(app);
    this.channelType = channelType;
    this.onExportAndDelete = onExportAndDelete;
    this.onDeleteOnly = onDeleteOnly;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("collab-confirm-modal");
    contentEl.createEl("h3", { text: `Delete ${this.channelType}?` });
    contentEl.createEl("p", {
      text: `This will permanently delete the ${this.channelType} and all its messages for everyone.`
    });
    contentEl.createEl("p", {
      text: "Would you like to export a copy of the chat before deleting?",
      cls: "collab-export-hint"
    });
    const buttonRow = contentEl.createEl("div", { cls: "collab-confirm-buttons collab-delete-options" });
    const cancelBtn = buttonRow.createEl("button", {
      text: "Cancel",
      cls: "collab-confirm-cancel-btn"
    });
    cancelBtn.addEventListener("click", () => this.close());
    const deleteOnlyBtn = buttonRow.createEl("button", {
      text: "Delete",
      cls: "collab-confirm-action-btn collab-delete-only-btn"
    });
    deleteOnlyBtn.addEventListener("click", () => {
      this.close();
      void (async () => {
        await this.onDeleteOnly();
      })();
    });
    const exportBtn = buttonRow.createEl("button", {
      text: "Export and delete",
      cls: "collab-confirm-action-btn collab-export-delete-btn"
    });
    exportBtn.addEventListener("click", () => {
      this.close();
      void (async () => {
        await this.onExportAndDelete();
      })();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var LeaveAsLastMemberModal = class extends import_obsidian4.Modal {
  constructor(app, channelType, onExportAndLeave, onLeaveOnly) {
    super(app);
    this.channelType = channelType;
    this.onExportAndLeave = onExportAndLeave;
    this.onLeaveOnly = onLeaveOnly;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("collab-confirm-modal");
    contentEl.createEl("h3", { text: `Leave ${this.channelType}?` });
    contentEl.createEl("p", {
      text: `You are the last member. Leaving will permanently delete this ${this.channelType} and all its messages.`
    });
    contentEl.createEl("p", {
      text: "Would you like to export a copy of the chat before leaving?",
      cls: "collab-export-hint"
    });
    const buttonRow = contentEl.createEl("div", { cls: "collab-confirm-buttons collab-delete-options" });
    const cancelBtn = buttonRow.createEl("button", {
      text: "Cancel",
      cls: "collab-confirm-cancel-btn"
    });
    cancelBtn.addEventListener("click", () => this.close());
    const leaveOnlyBtn = buttonRow.createEl("button", {
      text: "Leave",
      cls: "collab-confirm-action-btn collab-delete-only-btn"
    });
    leaveOnlyBtn.addEventListener("click", () => {
      this.close();
      void (async () => {
        await this.onLeaveOnly();
      })();
    });
    const exportBtn = buttonRow.createEl("button", {
      text: "Export and leave",
      cls: "collab-confirm-action-btn collab-export-delete-btn"
    });
    exportBtn.addEventListener("click", () => {
      this.close();
      void (async () => {
        await this.onExportAndLeave();
      })();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var NewReminderModal = class extends import_obsidian4.Modal {
  constructor(app, reminderManager, onCreated) {
    super(app);
    this.reminderManager = reminderManager;
    this.onCreated = onCreated;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("collab-reminder-modal");
    contentEl.createEl("h3", { text: "New reminder" });
    contentEl.createEl("label", { text: "What do you want to remember?" });
    const messageInput = contentEl.createEl("textarea", {
      cls: "collab-reminder-message-input",
      attr: { placeholder: "Enter your reminder...", rows: "3" }
    });
    contentEl.createEl("label", { text: "When?" });
    const dateInputWrapper = contentEl.createEl("div", { cls: "collab-reminder-date-wrapper" });
    const dateInput = dateInputWrapper.createEl("input", {
      cls: "collab-reminder-date-input",
      attr: {
        type: "text",
        placeholder: "Example: tomorrow 3pm, in 2 hours, next monday"
      }
    });
    const previewEl = contentEl.createEl("div", { cls: "collab-reminder-date-preview" });
    const suggestionsEl = dateInputWrapper.createEl("div", { cls: "collab-reminder-suggestions" });
    for (const suggestion of ReminderManager.getSuggestions().slice(0, 5)) {
      const chip = suggestionsEl.createEl("button", {
        text: suggestion,
        cls: "collab-reminder-suggestion-chip"
      });
      chip.addEventListener("click", () => {
        dateInput.value = suggestion;
        this.updateDatePreview(dateInput.value, previewEl);
      });
    }
    const calendarRow = contentEl.createEl("div", { cls: "collab-reminder-calendar-row" });
    calendarRow.createEl("span", { text: "Or pick a date: " });
    const calendarInput = calendarRow.createEl("input", {
      cls: "collab-reminder-calendar-input",
      attr: { type: "datetime-local" }
    });
    calendarInput.addEventListener("change", () => {
      if (calendarInput.value) {
        const date = new Date(calendarInput.value);
        dateInput.value = date.toLocaleString();
        this.updateDatePreview(dateInput.value, previewEl);
      }
    });
    dateInput.addEventListener("input", () => {
      this.updateDatePreview(dateInput.value, previewEl);
    });
    contentEl.createEl("label", { text: "Priority" });
    const prioritySelect = contentEl.createEl("select", { cls: "collab-reminder-priority-select" });
    prioritySelect.createEl("option", { value: "low", text: "Low priority" }).prepend("\u{1F535} ");
    prioritySelect.createEl("option", { value: "normal", text: "Normal priority" }).prepend("\u26AA ");
    prioritySelect.createEl("option", { value: "high", text: "High priority" }).prepend("\u{1F534} ");
    prioritySelect.value = "normal";
    const globalRow = contentEl.createEl("div", { cls: "collab-reminder-global-row" });
    const globalCheckbox = globalRow.createEl("input", {
      cls: "collab-reminder-global-checkbox",
      attr: { type: "checkbox", id: "reminder-global" }
    });
    const globalLabel = globalRow.createEl("label", {
      text: "Share with all team members",
      attr: { for: "reminder-global" }
    });
    globalLabel.addClass("collab-reminder-global-label");
    const buttonRow = contentEl.createEl("div", { cls: "collab-reminder-buttons" });
    const cancelBtn = buttonRow.createEl("button", {
      text: "Cancel",
      cls: "collab-reminder-cancel-btn"
    });
    cancelBtn.addEventListener("click", () => this.close());
    const createBtn = buttonRow.createEl("button", {
      text: "Create reminder",
      cls: "collab-reminder-create-btn"
    });
    createBtn.addEventListener("click", () => {
      const message = messageInput.value.trim();
      if (!message) {
        new import_obsidian4.Notice("Please enter a reminder message");
        return;
      }
      const dueDate = ReminderManager.parseNaturalDate(dateInput.value);
      if (!dueDate) {
        new import_obsidian4.Notice('Could not parse date. Try "tomorrow 3pm" or use the calendar picker.');
        return;
      }
      const priority = prioritySelect.value;
      const isGlobal = globalCheckbox.checked;
      void (async () => {
        await this.reminderManager.createReminder(message, dueDate, priority, void 0, isGlobal);
        new import_obsidian4.Notice(`Reminder set for ${ReminderManager.formatDueDate(dueDate.toISOString())}${isGlobal ? " (shared with team)" : ""}`);
        this.close();
        this.onCreated();
      })();
    });
    setTimeout(() => messageInput.focus(), 10);
  }
  updateDatePreview(input, previewEl) {
    if (!input.trim()) {
      previewEl.setText("");
      previewEl.removeClass("valid", "invalid");
      return;
    }
    const parsed = ReminderManager.parseNaturalDate(input);
    if (parsed) {
      previewEl.setText(`\u{1F4C5} ${parsed.toLocaleString()}`);
      previewEl.removeClass("invalid");
      previewEl.addClass("valid");
    } else {
      previewEl.setText("Could not parse date \u274C");
      previewEl.removeClass("valid");
      previewEl.addClass("invalid");
    }
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var EditReminderModal = class extends import_obsidian4.Modal {
  constructor(app, reminderManager, reminder, onUpdated) {
    super(app);
    this.reminderManager = reminderManager;
    this.reminder = reminder;
    this.onUpdated = onUpdated;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("collab-reminder-modal");
    contentEl.createEl("h3", { text: "Edit reminder" });
    contentEl.createEl("label", { text: "Message" });
    const messageInput = contentEl.createEl("textarea", {
      cls: "collab-reminder-message-input",
      attr: { rows: "3" }
    });
    messageInput.value = this.reminder.message;
    contentEl.createEl("label", { text: "When?" });
    const dateInput = contentEl.createEl("input", {
      cls: "collab-reminder-date-input",
      attr: { type: "text" }
    });
    dateInput.value = new Date(this.reminder.dueDate).toLocaleString();
    const calendarRow = contentEl.createEl("div", { cls: "collab-reminder-calendar-row" });
    calendarRow.createEl("span", { text: "Or pick: " });
    const calendarInput = calendarRow.createEl("input", {
      cls: "collab-reminder-calendar-input",
      attr: { type: "datetime-local" }
    });
    const dueDate = new Date(this.reminder.dueDate);
    calendarInput.value = dueDate.toISOString().slice(0, 16);
    calendarInput.addEventListener("change", () => {
      if (calendarInput.value) {
        dateInput.value = new Date(calendarInput.value).toLocaleString();
      }
    });
    contentEl.createEl("label", { text: "Priority" });
    const prioritySelect = contentEl.createEl("select", { cls: "collab-reminder-priority-select" });
    prioritySelect.createEl("option", { value: "low", text: "Low priority" }).prepend("\u{1F535} ");
    prioritySelect.createEl("option", { value: "normal", text: "Normal priority" }).prepend("\u26AA ");
    prioritySelect.createEl("option", { value: "high", text: "High priority" }).prepend("\u{1F534} ");
    prioritySelect.value = this.reminder.priority;
    const buttonRow = contentEl.createEl("div", { cls: "collab-reminder-buttons" });
    const cancelBtn = buttonRow.createEl("button", {
      text: "Cancel",
      cls: "collab-reminder-cancel-btn"
    });
    cancelBtn.addEventListener("click", () => this.close());
    const saveBtn = buttonRow.createEl("button", {
      text: "Save",
      cls: "collab-reminder-create-btn"
    });
    saveBtn.addEventListener("click", () => {
      const message = messageInput.value.trim();
      if (!message) {
        new import_obsidian4.Notice("Please enter a reminder message");
        return;
      }
      let newDueDate = ReminderManager.parseNaturalDate(dateInput.value);
      if (!newDueDate) {
        newDueDate = new Date(dateInput.value);
        if (isNaN(newDueDate.getTime())) {
          new import_obsidian4.Notice("Could not parse date");
          return;
        }
      }
      const priority = prioritySelect.value;
      void (async () => {
        await this.reminderManager.editReminder(this.reminder.id, {
          message,
          dueDate: newDueDate.toISOString(),
          priority
        });
        new import_obsidian4.Notice("Reminder updated");
        this.close();
        this.onUpdated();
      })();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var SnoozeModal = class extends import_obsidian4.Modal {
  constructor(app, reminderManager, reminderId, onSnoozed) {
    super(app);
    this.reminderManager = reminderManager;
    this.reminderId = reminderId;
    this.onSnoozed = onSnoozed;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("collab-snooze-modal");
    contentEl.createEl("h3", { text: "Snooze reminder" });
    contentEl.createEl("p", { text: "Remind me again in..." });
    const optionsEl = contentEl.createEl("div", { cls: "collab-snooze-options" });
    const snoozeOptions = [
      { label: "15 minutes", minutes: 15 },
      { label: "30 minutes", minutes: 30 },
      { label: "1 hour", minutes: 60 },
      { label: "2 hours", minutes: 120 },
      { label: "4 hours", minutes: 240 },
      { label: "Tomorrow 9am", minutes: -1 }
      // Special case
    ];
    for (const option of snoozeOptions) {
      const btn = optionsEl.createEl("button", {
        text: option.label,
        cls: "collab-snooze-option-btn"
      });
      btn.addEventListener("click", () => {
        void (async () => {
          if (option.minutes === -1) {
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            tomorrow.setHours(9, 0, 0, 0);
            const minutesUntil = Math.round((tomorrow.getTime() - Date.now()) / 6e4);
            await this.reminderManager.snoozeReminder(this.reminderId, minutesUntil);
          } else {
            await this.reminderManager.snoozeReminder(this.reminderId, option.minutes);
          }
          new import_obsidian4.Notice(`Reminder snoozed for ${option.label}`);
          this.close();
          this.onSnoozed();
        })();
      });
    }
    const cancelBtn = contentEl.createEl("button", {
      text: "Cancel",
      cls: "collab-snooze-cancel-btn"
    });
    cancelBtn.addEventListener("click", () => this.close());
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ReminderNotificationModal = class extends import_obsidian4.Modal {
  constructor(app, reminder, reminderManager, onAction) {
    super(app);
    this.reminder = reminder;
    this.reminderManager = reminderManager;
    this.onAction = onAction;
  }
  onOpen() {
    console.debug("[Collab-Mentions] ReminderNotificationModal onOpen called for:", this.reminder.id, this.reminder.message.substring(0, 30));
    const { contentEl, modalEl } = this;
    contentEl.empty();
    contentEl.addClass("collab-reminder-notification-modal");
    modalEl.addClass("collab-reminder-notification-container");
    const headerEl = contentEl.createEl("div", { cls: "collab-reminder-notif-header" });
    headerEl.createEl("span", { text: "\u23F0", cls: "collab-reminder-notif-icon" });
    headerEl.createEl("h2", { text: "Reminder" });
    if (this.reminder.isGlobal) {
      headerEl.createEl("span", { text: "Team \u{1F310}", cls: "collab-reminder-notif-global-badge" });
    }
    contentEl.createEl("div", {
      text: this.reminder.message,
      cls: "collab-reminder-notif-message"
    });
    if (this.reminder.isGlobal) {
      contentEl.createEl("div", {
        text: `Created by @${this.reminder.user}`,
        cls: "collab-reminder-notif-creator"
      });
    }
    if (this.reminder.priority !== "normal") {
      const priorityText = this.reminder.priority === "high" ? "\u{1F534} High Priority" : "\u{1F535} Low Priority";
      contentEl.createEl("div", { text: priorityText, cls: "collab-reminder-notif-priority" });
    }
    const actionsEl = contentEl.createEl("div", { cls: "collab-reminder-notif-actions" });
    const snoozeRow = actionsEl.createEl("div", { cls: "collab-reminder-notif-snooze-row" });
    snoozeRow.createEl("span", { text: "Snooze: " });
    const snoozeOptions = [
      { label: "15m", minutes: 15 },
      { label: "1h", minutes: 60 },
      { label: "4h", minutes: 240 }
    ];
    for (const option of snoozeOptions) {
      const snoozeBtn = snoozeRow.createEl("button", {
        text: option.label,
        cls: "collab-reminder-notif-snooze-btn"
      });
      snoozeBtn.addEventListener("click", () => {
        void (async () => {
          await this.reminderManager.snoozeReminder(this.reminder.id, option.minutes);
          new import_obsidian4.Notice(`Snoozed for ${option.label}`);
          this.close();
          this.onAction();
        })();
      });
    }
    const buttonRow = actionsEl.createEl("div", { cls: "collab-reminder-notif-buttons" });
    const completeBtn = buttonRow.createEl("button", {
      text: "Mark complete \u2713",
      cls: "collab-reminder-notif-complete-btn"
    });
    completeBtn.addEventListener("click", () => {
      void (async () => {
        await this.reminderManager.completeReminder(this.reminder.id);
        new import_obsidian4.Notice("Reminder completed!");
        this.close();
        this.onAction();
      })();
    });
    const dismissBtn = buttonRow.createEl("button", {
      text: "Dismiss",
      cls: "collab-reminder-notif-dismiss-btn"
    });
    dismissBtn.addEventListener("click", () => {
      this.close();
      this.onAction();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// main.ts
var CollabMentionsPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.fileWatcherInterval = null;
    this.heartbeatInterval = null;
    this.cleanupInterval = null;
    // Periodic cleanup of tracking Sets
    this.lastMentionsFileHash = null;
    this.lastChatFileHash = null;
    this.lastUsersFileHash = null;
    this.lastRemindersFileHash = null;
    this.notifiedMentionIds = /* @__PURE__ */ new Set();
    // Track already-notified mentions
    this.notifiedContentHashes = /* @__PURE__ */ new Set();
    // Track by content hash for extra robustness
    this.knownChannelIds = /* @__PURE__ */ new Set();
    // Track channels user is in
    this.ribbonIconEl = null;
    // Reference to ribbon icon for badge updates
    this.lastUnreadNotificationTime = 0;
    // Prevent repeated unread notifications
    this.wasSnoozing = false;
    // Track if user was snoozing
    this.lastKnownMessageIds = /* @__PURE__ */ new Map();
    // Track known message IDs per channel
    this.notifiedMessageHashes = /* @__PURE__ */ new Set();
    // Track message content hashes for notification dedup
    this.notifiedReminderIds = /* @__PURE__ */ new Set();
    // Track already-notified reminders
    this.lastCleanupTime = 0;
    /**
     * Show a centered notification modal (stacks multiple notifications)
     */
    this.activeNotifications = [];
  }
  // Track last cleanup time
  async onload() {
    console.debug("Loading Collab Mentions plugin");
    await this.loadSettings();
    await this.saveSettings();
    this.userManager = new UserManager(this.app);
    await this.userManager.loadUsers();
    this.userManager.identifyCurrentUser();
    this.mentionParser = new MentionParser(this.app, this.userManager);
    await this.mentionParser.loadMentions();
    this.chatManager = new ChatManager(this.app, this.userManager);
    await this.chatManager.loadChat();
    this.reminderManager = new ReminderManager(this.app, this.userManager);
    await this.reminderManager.loadReminders();
    this.reminderManager.setOnReminderDue((reminder) => {
      this.showReminderNotification(reminder);
    });
    this.notifier = new Notifier(this.app, this.mentionParser, this.userManager);
    this.registerView(
      MENTION_PANEL_VIEW_TYPE,
      (leaf) => new MentionPanelView(
        leaf,
        this.mentionParser,
        this.userManager,
        this.chatManager,
        this.reminderManager,
        () => this.updateRibbonBadge()
        // Callback to update badge when read status changes
      )
    );
    this.ribbonIconEl = this.addRibbonIcon("at-sign", "Collab mentions", async () => {
      if (!this.userManager.isRegistered()) {
        new RegisterModal(
          this.app,
          this.userManager,
          () => this.onUserRegistered()
        ).open();
      } else {
        await this.toggleMentionPanel();
      }
    });
    this.ribbonIconEl.addClass("collab-ribbon-icon");
    const badgeEl = this.ribbonIconEl.createEl("span", { cls: "collab-ribbon-badge collab-hidden" });
    this.addCommand({
      id: "open-mentions-panel",
      name: "Open mentions panel",
      callback: async () => {
        await this.activateMentionPanel();
      }
    });
    this.addCommand({
      id: "register-user",
      name: "Register / manage user",
      callback: () => {
        if (this.userManager.isRegistered()) {
          new UserManagementModal(
            this.app,
            this.userManager,
            () => this.onUserRegistered()
          ).open();
        } else {
          new RegisterModal(
            this.app,
            this.userManager,
            () => this.onUserRegistered()
          ).open();
        }
      }
    });
    this.addCommand({
      id: "check-mentions",
      name: "Check for new mentions",
      callback: async () => {
        await this.mentionParser.loadMentions();
        const count = await this.notifier.checkAndNotify(this.settings.notificationSound);
        if (count === 0) {
          this.notifier.showNotice("No new mentions");
        }
      }
    });
    this.addCommand({
      id: "mark-all-read",
      name: "Mark all mentions as read",
      callback: async () => {
        await this.mentionParser.markAllAsRead();
        this.notifier.showNotice("All mentions marked as read");
        this.refreshPanel();
      }
    });
    this.registerEditorSuggest(new MentionSuggest(this.app, this.userManager, this.chatManager));
    const pendingFiles = /* @__PURE__ */ new Map();
    let followUpTimer = null;
    const processFileForMentions = async (file) => {
      console.debug("[Collab-Mentions] Processing file for mentions:", file.path);
      if (this.userManager.isRegistered()) {
        const newMentions = await this.mentionParser.processFile(file);
        console.debug("[Collab-Mentions] New mentions found:", newMentions.length);
        for (const mention of newMentions) {
          console.debug("[Collab-Mentions] Notifying mention to:", mention.to);
          this.notifier.notifyNewMention(mention);
        }
      }
    };
    const debouncedProcessFile = (0, import_obsidian5.debounce)(
      async (file) => {
        console.debug("[Collab-Mentions] File modified (immediate):", file.path);
        await processFileForMentions(file);
      },
      1e3,
      true
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (file instanceof import_obsidian5.TFile && file.extension === "md") {
          debouncedProcessFile(file);
          pendingFiles.set(file.path, file);
          if (followUpTimer !== null) {
            window.clearTimeout(followUpTimer);
          }
          followUpTimer = window.setTimeout(() => {
            void (async () => {
              if (pendingFiles.size > 0) {
                console.debug("[Collab-Mentions] Follow-up processing", pendingFiles.size, "files");
                for (const [path, pendingFile] of pendingFiles) {
                  await processFileForMentions(pendingFile);
                }
                pendingFiles.clear();
              }
              followUpTimer = null;
            })();
          }, 1500);
        }
      })
    );
    this.addSettingTab(new CollabMentionsSettingTab(this.app, this));
    if (this.userManager.isRegistered() && this.settings.enableNotifications) {
      setTimeout(() => {
        void (async () => {
          await this.mentionParser.loadMentions();
          await this.chatManager.loadChat();
          await this.reminderManager.loadReminders();
          const currentUser = this.userManager.getCurrentUser();
          if (!currentUser)
            return;
          const username = currentUser.vaultName;
          if (!this.settings.notifiedMentionIdsByUser[username]) {
            this.settings.notifiedMentionIdsByUser[username] = [];
          }
          if (!this.settings.lastNotifiedChatTimestampByUser[username]) {
            this.settings.lastNotifiedChatTimestampByUser[username] = {};
          }
          const userNotifiedMentions = this.settings.notifiedMentionIdsByUser[username];
          const userChatTimestamps = this.settings.lastNotifiedChatTimestampByUser[username];
          const unreadMentions = this.mentionParser.getUnreadMentions();
          const notNotifiedYet = unreadMentions.filter(
            (m) => !userNotifiedMentions.includes(m.id)
          );
          if (notNotifiedYet.length > 0) {
            this.notifier.showStartupNotifications(notNotifiedYet);
            notNotifiedYet.forEach((m) => {
              if (!userNotifiedMentions.includes(m.id)) {
                userNotifiedMentions.push(m.id);
              }
            });
            const existingIds = new Set(this.mentionParser.getAllMentionIds());
            this.settings.notifiedMentionIdsByUser[username] = userNotifiedMentions.filter(
              (id) => existingIds.has(id)
            );
            await this.saveSettings();
          }
          const channels = this.chatManager.getChannelsForUser(username);
          let newUnreadCount = 0;
          for (const channel of channels) {
            const lastNotified = userChatTimestamps[channel.id];
            const lastNotifiedTime = lastNotified ? new Date(lastNotified).getTime() : 0;
            const messages = this.chatManager.getMessages(channel.id);
            const newMessages = messages.filter(
              (m) => new Date(m.timestamp).getTime() > lastNotifiedTime && m.from !== username && m.from !== "system" && !m.deleted
            );
            newUnreadCount += newMessages.length;
            if (messages.length > 0) {
              const latestMsg = messages[messages.length - 1];
              userChatTimestamps[channel.id] = latestMsg.timestamp;
            }
          }
          if (newUnreadCount > 0) {
            this.showCenteredNotification(
              "\u{1F4AC} Unread Messages",
              `You have ${newUnreadCount} unread chat message${newUnreadCount > 1 ? "s" : ""}`,
              () => {
                void this.activateMentionPanel({ tab: "chat" });
              }
            );
            await this.saveSettings();
          }
          const dueReminders = await this.reminderManager.checkDueReminders();
          if (dueReminders.length > 0) {
            console.debug("[Collab-Mentions] Due reminders on startup:", dueReminders.length);
            for (const reminder of dueReminders) {
              this.notifiedReminderIds.add(reminder.id);
            }
          }
          this.reminderManager.startPeriodicCheck(5e3);
          if (this.settings.autoCleanup) {
            await this.mentionParser.autoCleanupMentions(
              this.settings.maxMentionsPerUser,
              this.settings.cleanupIntervalHours
            );
          }
          this.updateRibbonBadge();
        })();
      }, 3e3);
    }
    if (this.settings.enableFileWatcher && this.userManager.isRegistered()) {
      this.startFileWatcher();
    }
    if (this.userManager.isRegistered()) {
      this.startHeartbeat();
    }
    if (!this.userManager.isRegistered()) {
      setTimeout(() => {
        this.notifier.showNotice(
          "\u{1F44B} Welcome to Collab Mentions! Click the @ icon to register.",
          1e4
        );
      }, 2e3);
    }
  }
  onunload() {
    console.debug("Unloading Collab Mentions plugin");
    this.stopFileWatcher();
    this.stopHeartbeat();
    this.stopCleanupInterval();
    this.reminderManager.stopPeriodicCheck();
    void (async () => {
      await this.userManager.clearPresence();
    })();
  }
  /**
   * Called after a user successfully registers - starts file watcher and heartbeat
   */
  onUserRegistered() {
    console.debug("[Collab-Mentions] User registered, starting services...");
    if (this.settings.enableFileWatcher) {
      this.startFileWatcher();
    }
    this.startHeartbeat();
    this.reminderManager.startPeriodicCheck(5e3);
    this.startCleanupInterval();
    this.refreshPanel();
  }
  /**
   * Show notification for a due reminder with centered modal
   */
  showReminderNotification(reminder) {
    console.debug("[Collab-Mentions] showReminderNotification called for:", reminder.message.substring(0, 30), "id:", reminder.id);
    if (this.notifiedReminderIds.has(reminder.id)) {
      console.debug("[Collab-Mentions] Skipping duplicate notification for reminder:", reminder.id);
      return;
    }
    this.notifiedReminderIds.add(reminder.id);
    const modal = new ReminderNotificationModal(
      this.app,
      reminder,
      this.reminderManager,
      () => this.refreshPanel()
    );
    console.debug("[Collab-Mentions] Opening ReminderNotificationModal for:", reminder.id);
    modal.open();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateMentionPanel(options) {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(MENTION_PANEL_VIEW_TYPE)[0];
    if (!leaf) {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        await rightLeaf.setViewState({
          type: MENTION_PANEL_VIEW_TYPE,
          active: true
        });
        leaf = rightLeaf;
      }
    }
    if (leaf) {
      void workspace.revealLeaf(leaf);
      const view = leaf.view;
      if (view) {
        if (options == null ? void 0 : options.channelId) {
          void view.switchToChannel(options.channelId);
        } else if (options == null ? void 0 : options.tab) {
          void view.switchToTab(options.tab);
        }
      }
    }
  }
  /**
   * Toggle the mention panel open/closed
   */
  async toggleMentionPanel() {
    const { workspace } = this.app;
    const leaves = workspace.getLeavesOfType(MENTION_PANEL_VIEW_TYPE);
    if (leaves.length > 0) {
      const leaf = leaves[0];
      const rightSplit = workspace.rightSplit;
      if (rightSplit && !rightSplit.collapsed) {
        leaf.detach();
        return;
      }
    }
    await this.activateMentionPanel();
  }
  refreshPanel(smartRefresh = false) {
    const leaves = this.app.workspace.getLeavesOfType(MENTION_PANEL_VIEW_TYPE);
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view) {
        if (smartRefresh && view.refreshChat) {
          void view.refreshChat();
        } else if (view.render) {
          void view.render();
        }
      }
    }
    this.updateRibbonBadge();
  }
  /**
   * Update the unread badge on the ribbon icon
   */
  updateRibbonBadge() {
    if (!this.ribbonIconEl)
      return;
    const badgeEl = this.ribbonIconEl.querySelector(".collab-ribbon-badge");
    if (!badgeEl)
      return;
    const unreadMentions = this.mentionParser.getUnreadMentions().length;
    let unreadChat = 0;
    const currentUser = this.userManager.getCurrentUser();
    if (currentUser) {
      const channels = this.chatManager.getChannelsForUser(currentUser.vaultName);
      for (const channel of channels) {
        if (this.chatManager.isChannelMuted(channel.id))
          continue;
        unreadChat += this.chatManager.getUnreadCount(channel.id, currentUser.vaultName);
      }
    }
    const totalUnread = unreadMentions + unreadChat;
    if (totalUnread > 0) {
      badgeEl.textContent = totalUnread > 99 ? "99+" : String(totalUnread);
      badgeEl.removeClass("collab-hidden");
      badgeEl.addClass("collab-visible");
    } else {
      badgeEl.removeClass("collab-visible");
      badgeEl.addClass("collab-hidden");
    }
  }
  /**
   * Fast non-cryptographic hash (FNV-1a) for file change detection
   * Consistent with hashing used in mentionParser, chatManager, userManager
   * Much faster than SHA-256 - optimized for speed, not security
   */
  computeContentHash(content) {
    let hash = 2166136261;
    for (let i = 0; i < content.length; i++) {
      hash ^= content.charCodeAt(i);
      hash = hash * 16777619 >>> 0;
    }
    return hash.toString(16);
  }
  /**
   * FILE WATCHER - Detect changes to mentions.json while vault is open
   */
  async getMentionsFileHash() {
    try {
      const mentionsPath = this.mentionParser.getMentionsFilePath();
      if (await this.app.vault.adapter.exists(mentionsPath)) {
        const content = await this.app.vault.adapter.read(mentionsPath);
        return this.computeContentHash(content);
      }
    } catch (e) {
      console.error("Failed to get mentions file hash:", e);
    }
    return null;
  }
  async checkForMentionsFileChanges() {
    const currentHash = await this.getMentionsFileHash();
    if (this.lastMentionsFileHash === null) {
      return;
    }
    if (currentHash && currentHash !== this.lastMentionsFileHash) {
      console.debug("Mentions file changed, reloading...");
      await this.mentionParser.loadMentions();
      const unread = this.mentionParser.getUnreadMentions();
      console.debug("[Collab-Mentions] Total unread mentions for current user:", unread.length);
      const newUnread = [];
      for (const mention of unread) {
        if (this.notifiedMentionIds.has(mention.id)) {
          console.debug("[Collab-Mentions] Skipping mention (already notified by ID):", mention.id, "from:", mention.from);
          continue;
        }
        const contentHash = this.mentionParser.getMentionContentHash(mention);
        if (this.notifiedContentHashes.has(contentHash)) {
          console.debug("[Collab-Mentions] Skipping mention (already notified by hash):", mention.id, "from:", mention.from);
          continue;
        }
        console.debug("[Collab-Mentions] NEW mention to notify:", mention.id, "from:", mention.from, "context:", mention.context.substring(0, 50));
        newUnread.push(mention);
        this.notifiedMentionIds.add(mention.id);
        this.notifiedContentHashes.add(contentHash);
      }
      if (newUnread.length > 0 && this.settings.enableNotifications) {
        console.debug("[Collab-Mentions] New unread mentions to notify:", newUnread.length);
        if (newUnread.length > 3) {
          const uniqueSenders = [...new Set(newUnread.map((m) => m.from))];
          const senderText = uniqueSenders.length === 1 ? `from @${uniqueSenders[0]}` : `from ${uniqueSenders.length} people`;
          this.showCenteredNotification(
            "\u{1F4E3} New Mentions",
            `You have ${newUnread.length} new mentions ${senderText}`,
            () => {
              void this.activateMentionPanel({ tab: "inbox" });
            }
          );
        } else {
          for (const mention of newUnread) {
            this.showCenteredNotification(
              "\u{1F4E3} New Mention",
              `@${mention.from} mentioned you: "${this.truncateText(mention.context, 50)}"`,
              () => {
                void this.activateMentionPanel({ tab: "inbox" });
              }
            );
          }
        }
        if (this.settings.notificationSound) {
          this.notifier.playSound();
        }
      }
      this.refreshPanel(true);
      if (this.settings.autoCleanup) {
        await this.mentionParser.autoCleanupMentions(
          this.settings.maxMentionsPerUser,
          this.settings.cleanupIntervalHours
        );
      }
      this.lastMentionsFileHash = currentHash;
    }
  }
  async getChatFileHash() {
    try {
      const chatPath = this.chatManager.getChatFilePath();
      if (await this.app.vault.adapter.exists(chatPath)) {
        const content = await this.app.vault.adapter.read(chatPath);
        return this.computeContentHash(content);
      }
    } catch (e) {
      console.error("Failed to get chat file hash:", e);
    }
    return null;
  }
  async checkForChatFileChanges() {
    const currentHash = await this.getChatFileHash();
    const currentUser = this.userManager.getCurrentUser();
    if (this.lastChatFileHash === null) {
      return;
    }
    if (currentHash && currentHash !== this.lastChatFileHash) {
      console.debug("Chat file changed, reloading...");
      await this.chatManager.loadChat();
      if (currentUser && this.settings.enableNotifications) {
        const currentChannels = this.chatManager.getChannelsForUser(currentUser.vaultName);
        const currentChannelIds = new Set(currentChannels.map((ch) => ch.id));
        for (const knownId of this.knownChannelIds) {
          if (!currentChannelIds.has(knownId)) {
            console.debug("[Collab-Mentions] User left channel, removing from known:", knownId);
            this.knownChannelIds.delete(knownId);
            this.lastKnownMessageIds.delete(knownId);
          }
        }
        const newChannels = currentChannels.filter((ch) => !this.knownChannelIds.has(ch.id));
        for (const channel of newChannels) {
          const isActuallyMember = channel.type === "general" || channel.members.includes(currentUser.vaultName);
          if (!isActuallyMember) {
            console.debug(
              "[Collab-Mentions] Skipping channel notification - user not actually a member:",
              channel.id,
              channel.name,
              "members:",
              channel.members
            );
            this.knownChannelIds.add(channel.id);
            continue;
          }
          const channelId = channel.id;
          console.debug(
            "[Collab-Mentions] User added to channel:",
            channel.id,
            channel.name,
            "members:",
            channel.members
          );
          this.showCenteredNotification(
            "\u{1F4AC} New Channel",
            `You were added to "${channel.name || "a conversation"}"`,
            () => {
              void this.activateMentionPanel({ channelId });
            }
          );
          this.knownChannelIds.add(channel.id);
          const messages = this.chatManager.getMessages(channel.id);
          this.lastKnownMessageIds.set(channel.id, new Set(messages.map((m) => m.id)));
          if (this.settings.notificationSound) {
            this.notifier.playSound();
          }
        }
        const newMessagesFromOthers = [];
        for (const channel of currentChannels) {
          if (!this.knownChannelIds.has(channel.id))
            continue;
          if (this.chatManager.isChannelMuted(channel.id))
            continue;
          const messages = this.chatManager.getMessages(channel.id);
          const knownIds = this.lastKnownMessageIds.get(channel.id) || /* @__PURE__ */ new Set();
          for (const msg of messages) {
            if (msg.from === currentUser.vaultName || msg.from === "system" || msg.deleted)
              continue;
            if (knownIds.has(msg.id))
              continue;
            const contentHash = this.chatManager.getMessageContentHash(msg);
            if (this.notifiedMessageHashes.has(contentHash))
              continue;
            newMessagesFromOthers.push({
              channelId: channel.id,
              channelName: channel.name,
              message: msg,
              contentHash
            });
          }
          this.lastKnownMessageIds.set(channel.id, new Set(messages.map((m) => m.id)));
        }
        if (newMessagesFromOthers.length > 0) {
          console.debug(
            "[Collab-Mentions] New messages from others:",
            newMessagesFromOthers.length,
            newMessagesFromOthers.map((m) => ({
              id: m.message.id,
              from: m.message.from,
              channel: m.channelName,
              hasImages: !!(m.message.images && m.message.images.length > 0),
              hasText: !!m.message.message
            }))
          );
          for (const { contentHash } of newMessagesFromOthers) {
            this.notifiedMessageHashes.add(contentHash);
          }
          if (newMessagesFromOthers.length > 5) {
            const uniqueSenders = [...new Set(newMessagesFromOthers.map((m) => m.message.from))];
            const uniqueChannels = [...new Set(newMessagesFromOthers.map((m) => m.channelName))];
            const channelText = uniqueChannels.length === 1 ? `in ${uniqueChannels[0]}` : `across ${uniqueChannels.length} channels`;
            const senderText = uniqueSenders.length === 1 ? `from @${uniqueSenders[0]}` : `from ${uniqueSenders.length} people`;
            const firstChannelId = newMessagesFromOthers[0].channelId;
            this.showCenteredNotification(
              "\u{1F4AC} New Messages",
              `${newMessagesFromOthers.length} new messages ${senderText} ${channelText}`,
              () => {
                void this.activateMentionPanel({ channelId: firstChannelId });
              }
            );
          } else {
            for (const { channelId, channelName, message } of newMessagesFromOthers) {
              let notificationText;
              const hasImages = message.images && message.images.length > 0;
              const hasText = message.message && message.message.trim().length > 0;
              if (hasText && hasImages) {
                notificationText = `@${message.from} in ${channelName}: "${this.truncateText(message.message, 30)}" \u{1F4F7}`;
              } else if (hasImages) {
                const imageCount = message.images.length;
                notificationText = `@${message.from} sent ${imageCount > 1 ? imageCount + " images" : "an image"} in ${channelName}`;
              } else {
                notificationText = `@${message.from} in ${channelName}: "${this.truncateText(message.message || "", 40)}"`;
              }
              this.showCenteredNotification(
                "\u{1F4AC} New Message",
                notificationText,
                () => {
                  void this.activateMentionPanel({ channelId });
                }
              );
            }
          }
          if (this.settings.notificationSound) {
            this.notifier.playSound();
          }
        }
      }
      this.refreshPanel(true);
      this.lastChatFileHash = currentHash;
    }
  }
  async getUsersFileHash() {
    try {
      const usersPath = this.userManager.getUsersFilePath();
      if (await this.app.vault.adapter.exists(usersPath)) {
        const content = await this.app.vault.adapter.read(usersPath);
        return this.computeContentHash(content);
      }
    } catch (e) {
      console.error("Failed to get users file hash:", e);
    }
    return null;
  }
  async checkForUsersFileChanges() {
    const currentHash = await this.getUsersFileHash();
    if (this.lastUsersFileHash === null) {
      this.lastUsersFileHash = currentHash;
      return;
    }
    if (currentHash && currentHash !== this.lastUsersFileHash) {
      console.debug("Users file changed, reloading...");
      await this.userManager.loadUsers();
      this.refreshPanel();
      this.lastUsersFileHash = currentHash;
    }
  }
  async getRemindersFileHash() {
    try {
      const remindersPath = this.reminderManager.getRemindersFilePath();
      if (await this.app.vault.adapter.exists(remindersPath)) {
        const content = await this.app.vault.adapter.read(remindersPath);
        return this.computeContentHash(content);
      }
    } catch (e) {
      console.error("Failed to get reminders file hash:", e);
    }
    return null;
  }
  async checkForRemindersFileChanges() {
    const currentHash = await this.getRemindersFileHash();
    if (this.lastRemindersFileHash === null) {
      return;
    }
    if (currentHash && currentHash !== this.lastRemindersFileHash) {
      console.debug("[Collab-Mentions] Reminders file changed, reloading...");
      await this.reminderManager.loadReminders();
      const dueReminders = await this.reminderManager.checkDueReminders();
      for (const reminder of dueReminders) {
        if (!this.notifiedReminderIds.has(reminder.id)) {
          this.notifiedReminderIds.add(reminder.id);
          console.debug("[Collab-Mentions] Notified for reminder:", reminder.id, reminder.message.substring(0, 30));
        }
      }
      this.refreshPanel();
      this.lastRemindersFileHash = currentHash;
    }
  }
  showCenteredNotification(title, message, onClick) {
    console.debug("[Collab-Mentions] showCenteredNotification called:", title, message);
    const notification = document.createElement("div");
    notification.className = "collab-stacked-notification";
    const existingCount = this.activeNotifications.length;
    const topOffset = 20 + existingCount * 90;
    notification.setCssProps({ "--notification-top": `${topOffset}px` });
    const titleEl = document.createElement("h3");
    titleEl.textContent = title;
    notification.appendChild(titleEl);
    const messageEl = document.createElement("p");
    messageEl.textContent = message;
    notification.appendChild(messageEl);
    const buttonRow = document.createElement("div");
    buttonRow.className = "collab-centered-notification-buttons";
    if (onClick) {
      const viewBtn = document.createElement("button");
      viewBtn.textContent = "View";
      viewBtn.className = "collab-centered-notification-view-btn";
      viewBtn.addEventListener("click", () => {
        onClick();
        this.removeNotification(notification);
      });
      buttonRow.appendChild(viewBtn);
    }
    const dismissBtn = document.createElement("button");
    dismissBtn.textContent = "Dismiss";
    dismissBtn.className = "collab-centered-notification-dismiss-btn";
    dismissBtn.addEventListener("click", () => this.removeNotification(notification));
    buttonRow.appendChild(dismissBtn);
    notification.appendChild(buttonRow);
    this.activeNotifications.push(notification);
    setTimeout(() => {
      this.removeNotification(notification);
    }, 1e4);
    document.body.appendChild(notification);
  }
  removeNotification(notification) {
    if (notification.parentNode) {
      notification.remove();
    }
    const index = this.activeNotifications.indexOf(notification);
    if (index > -1) {
      this.activeNotifications.splice(index, 1);
    }
    this.activeNotifications.forEach((n, i) => {
      n.setCssProps({ "--notification-top": `${20 + i * 90}px` });
    });
  }
  truncateText(text, maxLength) {
    if (text.length <= maxLength)
      return text;
    return text.substring(0, maxLength - 3) + "...";
  }
  startFileWatcher() {
    var _a;
    if (this.fileWatcherInterval !== null) {
      return;
    }
    console.debug("Starting mentions file watcher...");
    this.fileWatcherInterval = window.setInterval(() => {
      void (async () => {
        await this.checkForMentionsFileChanges();
        await this.checkForChatFileChanges();
        await this.checkForUsersFileChanges();
        await this.checkForRemindersFileChanges();
        await this.userManager.loadPresence();
      })();
    }, 3e3);
    void this.getMentionsFileHash().then((hash) => {
      this.lastMentionsFileHash = hash;
      console.debug("[Collab-Mentions] Initialized mentions hash");
    });
    void this.getChatFileHash().then((hash) => {
      this.lastChatFileHash = hash;
      console.debug("[Collab-Mentions] Initialized chat hash");
    });
    void this.getUsersFileHash().then((hash) => {
      this.lastUsersFileHash = hash;
      console.debug("[Collab-Mentions] Initialized users hash");
    });
    void this.getRemindersFileHash().then((hash) => {
      this.lastRemindersFileHash = hash;
      console.debug("[Collab-Mentions] Initialized reminders hash");
    });
    const unread = this.mentionParser.getUnreadMentions();
    unread.forEach((m) => {
      this.notifiedMentionIds.add(m.id);
      const contentHash = this.mentionParser.getMentionContentHash(m);
      this.notifiedContentHashes.add(contentHash);
    });
    console.debug("[Collab-Mentions] Initialized mention tracking:", unread.length, "mentions");
    const currentUser = this.userManager.getCurrentUser();
    if (currentUser) {
      const channels = this.chatManager.getChannelsForUser(currentUser.vaultName);
      channels.forEach((ch) => this.knownChannelIds.add(ch.id));
      for (const channel of channels) {
        const messages = this.chatManager.getMessages(channel.id);
        const messageIds = new Set(messages.map((m) => m.id));
        this.lastKnownMessageIds.set(channel.id, messageIds);
        for (const msg of messages) {
          if (msg.from !== currentUser.vaultName && msg.from !== "system") {
            const contentHash = this.chatManager.getMessageContentHash(msg);
            this.notifiedMessageHashes.add(contentHash);
          }
        }
      }
      console.debug("[Collab-Mentions] Initialized channel tracking:", channels.length, "channels");
      const reminders = this.reminderManager.getReminders();
      for (const reminder of reminders) {
        if (reminder.completed)
          continue;
        if (reminder.isGlobal) {
          if ((_a = reminder.notifiedUsers) == null ? void 0 : _a.includes(currentUser.vaultName)) {
            this.notifiedReminderIds.add(reminder.id);
          }
        } else if (reminder.user === currentUser.vaultName && reminder.notified) {
          this.notifiedReminderIds.add(reminder.id);
        }
      }
      console.debug("[Collab-Mentions] Initialized reminder tracking:", this.notifiedReminderIds.size, "notified reminders");
    }
    this.startCleanupInterval();
  }
  stopFileWatcher() {
    if (this.fileWatcherInterval !== null) {
      console.debug("Stopping mentions file watcher...");
      window.clearInterval(this.fileWatcherInterval);
      this.fileWatcherInterval = null;
    }
  }
  restartFileWatcher() {
    this.stopFileWatcher();
    if (this.settings.enableFileWatcher && this.userManager.isRegistered()) {
      this.startFileWatcher();
    }
  }
  /**
   * Start periodic cleanup of notification tracking Sets to prevent memory leaks.
   * Runs every 30 minutes and removes IDs that no longer exist in the system.
   */
  startCleanupInterval() {
    if (this.cleanupInterval !== null) {
      return;
    }
    console.debug("[Collab-Mentions] Starting periodic cleanup interval...");
    this.cleanupInterval = window.setInterval(() => {
      this.cleanupNotificationTracking();
    }, 30 * 60 * 1e3);
    setTimeout(() => this.cleanupNotificationTracking(), 60 * 1e3);
  }
  /**
   * Stop the cleanup interval
   */
  stopCleanupInterval() {
    if (this.cleanupInterval !== null) {
      console.debug("[Collab-Mentions] Stopping cleanup interval...");
      window.clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
  }
  /**
   * Clean up notification tracking Sets by removing IDs that no longer exist.
   * This prevents unbounded memory growth over time.
   */
  cleanupNotificationTracking() {
    const startSize = {
      mentionIds: this.notifiedMentionIds.size,
      contentHashes: this.notifiedContentHashes.size,
      messageHashes: this.notifiedMessageHashes.size,
      reminderIds: this.notifiedReminderIds.size,
      channelIds: this.knownChannelIds.size
    };
    const allMentions = this.mentionParser.getAllMentions();
    const validMentionIds = new Set(allMentions.map((m) => m.id));
    const validMentionHashes = new Set(allMentions.map((m) => this.mentionParser.getMentionContentHash(m)));
    this.notifiedMentionIds = new Set(
      [...this.notifiedMentionIds].filter((id) => validMentionIds.has(id))
    );
    this.notifiedContentHashes = new Set(
      [...this.notifiedContentHashes].filter((hash) => validMentionHashes.has(hash))
    );
    const currentUser = this.userManager.getCurrentUser();
    if (currentUser) {
      const channels = this.chatManager.getChannelsForUser(currentUser.vaultName);
      const validChannelIds = new Set(channels.map((ch) => ch.id));
      this.knownChannelIds = new Set(
        [...this.knownChannelIds].filter((id) => validChannelIds.has(id))
      );
      const validMessageHashes = /* @__PURE__ */ new Set();
      for (const channel of channels) {
        const messages = this.chatManager.getMessages(channel.id);
        for (const msg of messages) {
          validMessageHashes.add(this.chatManager.getMessageContentHash(msg));
        }
      }
      this.notifiedMessageHashes = new Set(
        [...this.notifiedMessageHashes].filter((hash) => validMessageHashes.has(hash))
      );
      for (const channelId of this.lastKnownMessageIds.keys()) {
        if (!validChannelIds.has(channelId)) {
          this.lastKnownMessageIds.delete(channelId);
        }
      }
    }
    const allReminders = this.reminderManager.getReminders();
    const validReminderIds = new Set(allReminders.map((r) => r.id));
    this.notifiedReminderIds = new Set(
      [...this.notifiedReminderIds].filter((id) => validReminderIds.has(id))
    );
    const endSize = {
      mentionIds: this.notifiedMentionIds.size,
      contentHashes: this.notifiedContentHashes.size,
      messageHashes: this.notifiedMessageHashes.size,
      reminderIds: this.notifiedReminderIds.size,
      channelIds: this.knownChannelIds.size
    };
    const cleaned = startSize.mentionIds - endSize.mentionIds + (startSize.contentHashes - endSize.contentHashes) + (startSize.messageHashes - endSize.messageHashes) + (startSize.reminderIds - endSize.reminderIds) + (startSize.channelIds - endSize.channelIds);
    if (cleaned > 0) {
      console.debug("[Collab-Mentions] Cleanup completed:", {
        mentionIds: `${startSize.mentionIds} \u2192 ${endSize.mentionIds}`,
        contentHashes: `${startSize.contentHashes} \u2192 ${endSize.contentHashes}`,
        messageHashes: `${startSize.messageHashes} \u2192 ${endSize.messageHashes}`,
        reminderIds: `${startSize.reminderIds} \u2192 ${endSize.reminderIds}`,
        channelIds: `${startSize.channelIds} \u2192 ${endSize.channelIds}`,
        totalCleaned: cleaned
      });
    }
    this.lastCleanupTime = Date.now();
  }
  /**
   * HEARTBEAT - Update presence every 10 seconds for online status
   * FILE ACTIVITY - Record when user interacts with files (for active vs snooze status)
   */
  startHeartbeat() {
    if (this.heartbeatInterval !== null) {
      return;
    }
    console.debug("Starting presence heartbeat...");
    const getActiveFile = () => {
      const activeFile = this.app.workspace.getActiveFile();
      return activeFile == null ? void 0 : activeFile.path;
    };
    void this.userManager.recordFileActivity(getActiveFile());
    this.heartbeatInterval = window.setInterval(() => {
      void (async () => {
        await this.userManager.updateHeartbeat(getActiveFile());
      })();
    }, 1e4);
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", async () => {
        const currentUser = this.userManager.getCurrentUser();
        if (currentUser) {
          const statusBeforeActivity = this.userManager.getUserStatus(currentUser.vaultName);
          this.wasSnoozing = statusBeforeActivity === "snooze";
        }
        await this.userManager.recordFileActivity(getActiveFile());
        if (this.wasSnoozing && currentUser && this.settings.enableNotifications) {
          const now = Date.now();
          if (now - this.lastUnreadNotificationTime > 5 * 60 * 1e3) {
            const unreadCount = this.chatManager.getTotalUnreadCount(currentUser.vaultName);
            if (unreadCount > 0) {
              this.showCenteredNotification(
                "\u{1F4AC} Welcome Back!",
                `You have ${unreadCount} unread message${unreadCount > 1 ? "s" : ""} while you were away`,
                () => {
                  void this.activateMentionPanel({ tab: "chat" });
                }
              );
              this.lastUnreadNotificationTime = now;
            }
          }
          this.wasSnoozing = false;
        }
      })
    );
  }
  stopHeartbeat() {
    if (this.heartbeatInterval !== null) {
      console.debug("Stopping presence heartbeat...");
      window.clearInterval(this.heartbeatInterval);
      this.heartbeatInterval = null;
    }
  }
};
var MentionSuggest = class extends import_obsidian5.EditorSuggest {
  constructor(app, userManager, chatManager) {
    super(app);
    this.userManager = userManager;
    this.chatManager = chatManager;
  }
  onTrigger(cursor, editor, file) {
    const line = editor.getLine(cursor.line);
    const subString = line.substring(0, cursor.ch);
    const channelMatch = subString.match(/@#([\w-]*)$/);
    const userMatch = subString.match(/@(\w*)$/);
    if (channelMatch) {
      return {
        start: { line: cursor.line, ch: cursor.ch - channelMatch[0].length },
        end: cursor,
        query: "#" + channelMatch[1]
      };
    }
    if (userMatch) {
      return {
        start: { line: cursor.line, ch: cursor.ch - userMatch[0].length },
        end: cursor,
        query: userMatch[1]
      };
    }
    return null;
  }
  getSuggestions(context) {
    const query = context.query.toLowerCase();
    if (query.startsWith("#")) {
      const channelQuery = query.substring(1);
      const currentUser2 = this.userManager.getCurrentUser();
      if (!currentUser2)
        return [];
      const channels = this.chatManager.getChannelsForUser(currentUser2.vaultName);
      return channels.filter((ch) => ch.name.toLowerCase().includes(channelQuery)).map((ch) => ({
        vaultName: ch.name,
        color: "#3b82f6",
        type: "channel",
        channelId: ch.id,
        description: ch.type === "dm" ? "Direct message" : ch.type === "group" ? "Group" : "Channel"
      }));
    }
    const users = this.userManager.getAllUsers();
    const currentUser = this.userManager.getCurrentUser();
    const specialMentions = [
      { vaultName: "everyone", color: "#ef4444", isSpecial: true, type: "special", description: "Notify all users" }
    ];
    const filteredSpecial = specialMentions.filter(
      (s) => s.vaultName.toLowerCase().includes(query)
    );
    const filteredUsers = users.filter((user) => {
      if (currentUser && user.vaultName === currentUser.vaultName) {
        return false;
      }
      return user.vaultName.toLowerCase().includes(query);
    }).map((user) => ({
      vaultName: user.vaultName,
      color: user.color,
      os: user.os,
      type: "user"
    }));
    return [...filteredSpecial, ...filteredUsers];
  }
  renderSuggestion(suggestion, el) {
    const container = el.createEl("div", { cls: "collab-suggestion" });
    if (suggestion.type === "channel") {
      container.createEl("span", {
        text: "#",
        cls: "collab-channel-icon"
      });
      container.createEl("span", {
        text: suggestion.vaultName,
        cls: "collab-suggestion-name"
      });
      if (suggestion.description) {
        container.createEl("span", {
          text: suggestion.description,
          cls: "collab-suggestion-os"
        });
      }
    } else {
      const colorDot = container.createEl("span", { cls: "collab-user-dot" });
      colorDot.setCssProps({ "--user-dot-color": suggestion.color || "#7c3aed" });
      container.createEl("span", {
        text: `@${suggestion.vaultName}`,
        cls: "collab-suggestion-name"
      });
      if (suggestion.isSpecial && suggestion.description) {
        container.createEl("span", {
          text: suggestion.description,
          cls: "collab-suggestion-os"
        });
      } else if (suggestion.os) {
        container.createEl("span", {
          text: suggestion.os,
          cls: "collab-suggestion-os"
        });
      }
    }
  }
  selectSuggestion(suggestion, evt) {
    if (!this.context)
      return;
    const editor = this.context.editor;
    const start = this.context.start;
    const end = this.context.end;
    if (suggestion.type === "channel") {
      editor.replaceRange(`@#${suggestion.vaultName} `, start, end);
    } else {
      editor.replaceRange(`@${suggestion.vaultName} `, start, end);
    }
  }
};
var CollabMentionsSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian5.Setting(containerEl).setName("Registration").setHeading();
    const currentUser = this.plugin.userManager.getCurrentUser();
    const isAdmin = this.plugin.userManager.isCurrentUserAdmin();
    if (currentUser) {
      const userInfoEl = containerEl.createEl("div", { cls: "collab-settings-user-info" });
      const userNameEl = userInfoEl.createEl("p");
      userNameEl.createEl("span", { text: `Registered as: @${currentUser.vaultName}` });
      if (isAdmin) {
        const isPrimary = this.plugin.userManager.isCurrentUserPrimaryAdmin();
        userNameEl.createEl("span", {
          text: isPrimary ? " (Primary admin)" : " (Secondary admin)",
          cls: isPrimary ? "collab-admin-badge collab-primary-admin" : "collab-admin-badge"
        });
      }
      if (currentUser.registrationNumber) {
        userNameEl.createEl("span", {
          text: ` #${currentUser.registrationNumber}`,
          cls: "collab-registration-number"
        });
      }
      userInfoEl.createEl("p", {
        text: `Machine: ${currentUser.localIdentifier}`,
        cls: "setting-item-description"
      });
    } else {
      const registerBtn = containerEl.createEl("button", {
        text: "Register now",
        cls: "mod-cta"
      });
      registerBtn.addEventListener("click", () => {
        new RegisterModal(
          this.app,
          this.plugin.userManager,
          () => this.display()
        ).open();
      });
    }
    new import_obsidian5.Setting(containerEl).setName("Real-time monitoring").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Enable file watcher").setDesc("Monitor for changes in real-time (checks every 3 seconds)").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableFileWatcher).onChange(async (value) => {
        this.plugin.settings.enableFileWatcher = value;
        await this.plugin.saveSettings();
        this.plugin.restartFileWatcher();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Notifications").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Enable notifications").setDesc("Show notifications for new mentions when opening the vault").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableNotifications).onChange(async (value) => {
        this.plugin.settings.enableNotifications = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Notification sound").setDesc("Play a sound when you have new mentions").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.notificationSound).onChange(async (value) => {
        this.plugin.settings.notificationSound = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Auto-cleanup").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Enable auto-cleanup").setDesc("Automatically limit mentions per user to prevent file bloat").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.autoCleanup).onChange(async (value) => {
        this.plugin.settings.autoCleanup = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Max mentions per user").setDesc("Keep only this many recent mentions per user (unread always kept)").addSlider(
      (slider) => slider.setLimits(10, 100, 5).setValue(this.plugin.settings.maxMentionsPerUser).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxMentionsPerUser = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Cleanup interval").setDesc("How often to run auto-cleanup (hours)").addSlider(
      (slider) => slider.setLimits(1, 168, 1).setValue(this.plugin.settings.cleanupIntervalHours).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.cleanupIntervalHours = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Appearance").setHeading();
    new import_obsidian5.Setting(containerEl).setName("Highlight mentions").setDesc("Visually highlight @mentions in the editor").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showMentionHighlights).onChange(async (value) => {
        this.plugin.settings.showMentionHighlights = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Mention highlight color").setDesc("Color used to highlight @mentions").addText(
      (text) => text.setPlaceholder("#7c3aed").setValue(this.plugin.settings.mentionColor).onChange(async (value) => {
        this.plugin.settings.mentionColor = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Maintenance").setHeading();
    let cleanupScope = "my-received";
    let cleanupDays = 30;
    new import_obsidian5.Setting(containerEl).setName("Cleanup scope").setDesc("Choose which mentions to clean up" + (isAdmin ? "" : " (Admin-only options hidden)")).addDropdown((dropdown) => {
      dropdown.addOption("my-received", "My received mentions (inbox)").addOption("my-sent", "My sent mentions");
      if (isAdmin) {
        dropdown.addOption("all", "All mentions (everyone) [admin]");
      }
      dropdown.setValue(cleanupScope).onChange((value) => {
        cleanupScope = value;
      });
    });
    new import_obsidian5.Setting(containerEl).setName("Cleanup age").setDesc("Only remove read mentions older than X days (0 = all read mentions)").addSlider(
      (slider) => slider.setLimits(0, 90, 1).setValue(cleanupDays).setDynamicTooltip().onChange((value) => {
        cleanupDays = value;
      })
    );
    new import_obsidian5.Setting(containerEl).setName("Run cleanup").setDesc("Remove read mentions based on scope and age settings above").addButton(
      (btn) => btn.setButtonText("Clean up").onClick(async () => {
        const currentUser2 = this.plugin.userManager.getCurrentUser();
        if (!currentUser2 && cleanupScope !== "all") {
          new import_obsidian5.Notice("You must be registered to clean up your mentions");
          return;
        }
        const targetUser = (currentUser2 == null ? void 0 : currentUser2.vaultName) || "";
        const scopeLabel = cleanupScope === "my-received" ? "received" : cleanupScope === "my-sent" ? "sent" : "all";
        const removed = await this.plugin.mentionParser.cleanupMentionsScoped(
          cleanupScope,
          targetUser,
          cleanupDays
        );
        new import_obsidian5.Notice(`Removed ${removed} ${scopeLabel} mentions`);
        this.plugin.refreshPanel();
      })
    );
    if (isAdmin) {
      new import_obsidian5.Setting(containerEl).setName("Force auto-cleanup now").setDesc("Run auto-cleanup immediately for all users, keeping the last configured number per user.").addButton(
        (btn) => btn.setButtonText("Run auto-cleanup").onClick(async () => {
          const removed = await this.plugin.mentionParser.autoCleanupMentions(
            this.plugin.settings.maxMentionsPerUser,
            0
            // Force run by setting interval to 0
          );
          new import_obsidian5.Notice(`Auto-cleanup: removed ${removed} mentions`);
          this.plugin.refreshPanel();
        })
      );
    }
    new import_obsidian5.Setting(containerEl).setName("Manage team members").setDesc("View and manage registered users").addButton(
      (btn) => btn.setButtonText("Manage").onClick(() => {
        new UserManagementModal(
          this.app,
          this.plugin.userManager,
          () => this.display()
        ).open();
      })
    );
  }
};
